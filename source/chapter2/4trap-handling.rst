处理 Trap
=======================

.. toctree::
   :hidden:
   :maxdepth: 5

我们知道，批处理系统被设计为运行在 S 模式，这是由作为它运行环境的 SEE 所保证的；而应用程序被设计为运行在 U 模式，这个则是我们的批处理系统
所保证的。批处理系统作为应用程序的执行环境，需要在执行应用程序之前进行一些初始化工作，并监控应用程序的执行，具体体现在：

- 当应用程序发起系统调用之后，需要到批处理系统中进行处理；
- 当应用程序执行出错的时候，需要到批处理系统中杀死该应用并加载运行下一个应用； 
- 当应用程序执行结束的时候，需要到批处理系统中加载运行下一个应用（实际上也是通过系统调用 ``sys_exit`` 来实现的）。

这些处理都涉及到特权级切换，因此都需要硬件提供的 Trap 机制。当从一般意义上讨论 RISC-V 架构的 Trap 机制时，通常需要注意两点：在
触发 Trap 之前 CPU 运行在哪个特权级；以及 CPU 需要切换到哪个特权级来处理该 Trap 并在处理完成之后返回原特权级。但本章中我们仅考虑
当 CPU 在 U 特权级运行用户程序的时候触发 Trap，并切换到 S 特权级的批处理系统的对应服务代码来进行处理。

在 RISC-V 架构中，关于 Trap 有一条重要的规则：在 Trap 前后特权级不会下降。因此如果触发 Trap 之后切换到 S 特权级（下称 Trap 到 S），
说明 Trap 发生之前 CPU 只能运行在 S/U 特权级。但无论如何，只要是 Trap 到 S，硬件就会使用 S 特权级与 Trap 相关的 CSR 来辅助 Trap 
处理。我们在编写运行在 S 特权级的批处理系统中的 Trap 处理相关代码的时候，也需要使用它们。

.. list-table:: 进入 S 特权级 Trap 的相关 CSR
   :header-rows: 1
   :align: center
   :widths: 30 100

   * - CSR 名
     - 该 CSR 与 Trap 相关的功能
   * - sstatus
     - ``SPP`` 字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）
   * - sepc
     - 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址
   * - scause
     - 描述 Trap 的原因
   * - stval
     - 给出 Trap 附加信息
   * - stvec
     - 控制 Trap 处理代码的入口地址

.. note::

   **多功能的 sstatus**

   注意 ``sstatus`` 是 S 特权级最重要的 CSR，可以从很多方面控制 S 特权级的行为并描述其状态。我们在这里先给出它对 Trap 处理的作用。

大多数的 Trap 发生的场景都是在执行某条指令之后，CPU 发现触发了一个 Trap 并需要进行处理。异常是 Trap 的一种，它与某条指令的执行有关，
但这条触发 Trap 的指令和进入 Trap 之前执行的最后一条指令不一定是同一条。如果这个异常并非不可恢复的错误，比如只是通过 ``ecall`` 指令
向底层执行环境请求某项功能，那么上层软件期待底层环境处理完成后，还能够从上层软件被打断的位置继续执行，参考 :ref:`图示 <environment-call-flow>` 。

.. _term-execution-of-thread:

回顾第一章的 :ref:`函数调用与栈 <function-call-and-stack>` ，我们知道在一个固定的 CPU 上，只要有一个栈作为存储空间，我们就能以多种
普通控制流（顺序、分支、循环结构和多层嵌套函数调用）组合的方式，来一行一行的执行源代码（以编程语言级的视角），也是一条一条的执行汇编指令
（以汇编语言级的视角）。只考虑普通控制流，那么从某条指令开始记录，该 CPU 可用的所有资源，包括自带的所有通用寄存器（包括虚拟的描述当前执行
指令地址的寄存器 pc ）和当前特权级可用的 CSR 以及位于内存中的一块栈空间，它们会随着指令的执行而逐渐发生变化。这种局限在普通控制流之内的
连续指令执行和与之同步的对相关资源的改变我们用一个新名词 **执行流** (Execution of thread) 来命名。执行流的状态是一个由它衍生出来的
概念，表示截止到某条指令执行完毕所有相关资源（包括寄存器、栈）的状态集合，它完整描述了自记录起始之后该执行流的指令执行历史。

.. note::

   实际上 CPU 还有其他资源可用：

   - 内存除了与执行流绑定的栈之外的其他存储空间，比如程序中的数据段；
   - 外围 I/O 设备。

   它们也会在执行期间动态发生变化。但它们可能由多条执行流共享，难以清晰的从中单独区分出某一条执行流的状态变化。因此在执行流概念中，
   我们不将其纳入考虑。

让我们从 U 特权级 Trap 到 S 的情况（这是一个特例，实际上在 Trap 前后特权级可能不变）来分析一下在 Trap 前后发生了哪些事情。首先，
我们目前唯一的 CPU 正处在 U 特权级运行着一个执行流跑着应用程序的代码。但是在执行完某一条指令之后， CPU 忽然发现这个执行流暂时无法再
继续下去，而是需要 Trap 到 S 去执行批处理系统提供的相应服务代码，等到执行完了之后再回过头来运行应用程序执行流。我们可以将 
CPU 中间在 S 特权级执行的那一段也看成一个执行流，因为它全程只是以普通控制流的模式在 S 特权级执行。这个执行流的意义就在于处理 Trap ，
我们可以将其称之为 Trap 执行流，它在应用程序执行流运行期间产生。

概括的说，从执行流的角度来看待 Trap 将会得出这样的结论： CPU 从应用程序执行流切换到 Trap 执行流，然后再切换回来继续运行。站在应用
程序的角度， Trap 机制对它是完全透明的，无论在实际执行的时候它在哪一条指令执行结束后进入 Trap ，它总是相信在 Trap 结束之后 CPU 能够
以和被打断的时候相同的执行流状态来继续运行执行流，就好像 Trap 从未发生过一样。

.. note::

	这里所说的相同并不是绝对相同，但是其变化是完全能够被应用程序预知到的。比如应用程序通过 ``ecall`` 指令请求底层高特权级软件的功能，
	由调用规范它知道 Trap 之后 ``a0~a1`` 两个寄存器会被用来保存返回值，所以会发生变化。这个信息是应用程序明确知晓的，但某种程度上
	确实也体现了执行流的变化。

在切换前后维持执行流状态的不变并不容易。执行流状态可以分为寄存器和栈两部分。对于寄存器而言，每个 CPU 只有一套通用寄存器，在运行 Trap 
执行流期间，我们会用到这些寄存器，这将难以维持它们的不变性。因此，就和函数调用需要保存函数调用上下文/活动记录一样，在实际运行 Trap 执行流
修改这些寄存器之前，我们也需要在某个地方保存这些寄存器并在后续恢复，事实上也是在某个栈上。除了通用寄存器之外还有一些可能在 Trap 前后被修改的
CSR，比如 CPU 所在的特权级。我们要保证它们的变化在我们的预期之内，比如对于特权级而言应该是 Trap 之前在 U 特权级，处理 Trap 的时候在 S 
特权级，返回之后又需要回到 U 特权级。而对于栈问题则相对简单，只要两个执行流用来记录执行历史的栈所对应的内存区域不相交，就不会产生令我们
头痛的覆盖问题，也就无需进行保存/恢复。

执行流切换的相关机制一部分由硬件帮我们完成，另一部分则需要由我们自己软件实现。

Trap 的硬件机制
-------------------------------------

.. 
   马老师发生甚么事了？
   --
   这里要说明目前只考虑从 U Trap 到 S ，而实际上 Trap 的要素就有：Trap 之前在哪个特权级，Trap 在哪个特权级处理。这个对于中断和异常
   都是如此，只不过中断可能跟特权级的关系稍微更紧密一点。毕竟中断的类型都是跟特权级挂钩的。但是对于 Trap 而言有一点是共同的，也就是触发 
   Trap 不会导致优先级下降。从中断/异常的代理就可以看出从定义上就不允许代理到更低的优先级。而且代理只能逐级代理，目前我们能操作的只有从 
   M 代理到 S，其他代理都基本只出现在指令集拓展或者硬件还不支持。中断的情况是，如果是属于某个特权级的中断，不能在更低的优先级处理。事实上
   这个中断只可能在 CPU 处于不会更高的优先级上收到（否则会被屏蔽），而 Trap 之后优先级不会下降（Trap 代理机制决定），这样就自洽了。
   --
   之前提到异常是说需要执行环境功能的原因与某条指令的执行有关。而 Trap 的定义更加广泛一些，就是在执行某条指令之后发现需要执行环境的功能，
   如果是中断的话 Trap 回来之后默认直接执行下一条指令，如果是异常的话硬件会将 sepc 设置为 Trap 发生之前最后执行的那条指令，而异常发生
   的原因不一定和这条指令的执行有关。应该指出的是，在大多数情况下都是和最后这条指令的执行有关。但在缓存的作用下也会出现那种特别极端的情况。
   --
   然后是 Trap 到 S，就有 S 模式的一些相关 CSR，以及从 U Trap 到 S，硬件会做哪些事情（包括触发异常的一瞬间，以及处理完成调用 sret 
   之后）。然后指出从用户的视角来看，如果是 ecall 的话， Trap 回来之后应该从 ecall 的下一条指令开始执行，且执行现场不能发生变化。
   所以就需要将应用执行环境保存在内核栈上（还需要换栈！）。栈存在的原因可能是 Trap handler 是一条新的运行在 S 特权级的执行流，所以
   这个可以理解成跨特权级的执行流切换，确实就复杂一点，要保存的内容也相对多一点。而下一章多任务的任务切换是全程发生在 S 特权级的执行流
   切换，所以会简单一点，保存的通用寄存器大概率更少（少在调用者保存寄存器），从各种意义上都很像函数调用。从不同特权级的角度来解释换栈
   是出于安全性，应用不应该看到 Trap 执行流的栈，这样做完之后，虽然理论上可以访问，但应用不知道内核栈的位置应该也有点麻烦。
   --
   然后是 rust_trap 的处理，尤其是奇妙的参数传递，内部处理逻辑倒是非常简单。
   --
   最后是如何利用 __restore 初始化应用的执行环境，包括如何设置入口点、用户栈以及保证在 U 特权级执行。





