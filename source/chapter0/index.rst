.. _link-chapter0:

第零章：操作系统概述
==============================================

.. toctree::
   :hidden:
   :maxdepth: 4

   1what-is-os
   2os-interface
   3os-hw-abstract
   4os-features
   5setup-devel-env


**为何要写这本操作系统书**


现在国内外已有一系列优秀的操作系统教材,例如William Stallings的《Operating Systems Internals and Design Principles》，Avi Silberschatz、Peter Baer Galvin 和 Greg Gagne 的《Operating System Concepts》，Remzi H. Arpaci-Dusseau 和 Andrea C. Arpaci-Dusseau 的《Operating Systems: Three Easy Pieces》等。然而,从我们从2000年以来的教学实践来看,某些经典教材对操作系统的概念和原理很重视，但缺乏对操作系统的概念/原理与操作系统的实现之间建立一个联系的桥梁，导致学生发现操作系统实现相关的实验与操作系统的概念相比，有较大的鸿沟。此外,部分教材把 x86 作为的操作系统实验的硬件参考平台，缺乏对当前快速发展的RISC-V等体系结构的实验支持，使得学生在操作系统实验中可能需要花较大代价了解相对繁杂的x86硬件细节，影响操作系统实验的效果。还有部分教材也基本以 Linux/Unix 等实际操作系统为主，难以让学生在一个学期内掌握其中的核心设计。

对于在校的学生和已经参加工作的工程师而言，能否以较小的时间和精力比较全面地了解操作系统呢？陆游老夫子说过“纸上得来终觉浅，绝知此事要躬行”，也许在了解基本的操作系统概念和原理基础上，通过实际动手来一步一步分析、设计和实现一个操作系统，会发现操作系统原来如此，概念原理和实际实现之间有紧密的联系和巨大的差异。

也许学生有疑问，在本科期间自己能通过设计实现一个操作系统吗？这一点其实已经是一个实际存在的现实情况了。MIT教授 Frans Kaashoek等师生设计实现了基于UNIX v6的xv6教学操作系统用于每年的本科操作系统课的实验中，而且在2019年，他们进一步改进了xv6，让其运行在RISC-V CPU上。RISC-V CPU同样来源于高校，是Berkeley教授David Patterson等师生设计实现的第五代RISC CPU（现在简称RISC-V），用于计算机组成原理和计算机体系机构课程的教学和科研中。


这些都给了我们很大的启发：对一个计算机专业的本科生而言，设计实现一个操作系统（包括CPU）有挑战但可行！ 所以本书的目标是以简洁的RISC-V CPU为底层硬件基础，根据上层应用从小到大的需求，逐步讲解如何设计并实现满足这些需求的“从小到大”的多个操作系统。并在实现操作系统的过程中，逐步解析操作系统各种概念与原理的知识点，对应的做到有“理”可循和有“码”可查，最终让读者了解和掌握操作系统的原理、设计与实现。

在具体撰写过程中，第零章是对操作系统的一个概述，让读者对操作系统的历史、定义、特征等概念上有一个大致的了解。后面的每个章节体现了操作系统的一个微缩的历史发展过程，即从对应用由简到繁的支持的角度出发，每章会讲解如何设计一个可运行应用的操作系统，满足应用的阶段性需求。从而读者可以通过对应配套的操作系统设计实验，了解如何从一个微不足道的小操作系统，根据应用需求，添加或增强操作系统功能，逐步形成一个类似UNIX的相对完善的操作系统。每一步都小到足以让人感觉到易于掌控，而在每一步结束时，你都有一个可以工作的操作系统。另外，通过足够详尽的测试程序 ，可以随时验证读者实现的操作系统在每次更新后是否正常工作。由于实验的代码规模和实现复杂度在一个逐步递增的可控范围内，读者可以结合对应于操作系统设计实验的进一步的原理讲解，来建立操作系统概念原理和实际实现的对应关系，从而能够通过操作系统实验的实践过程来加强对理论概念的理解，通过理论概念来进一步指导操作系统实验的实现与改进。

在你开始阅读与实践本书讲解的内容之前，你需要决定用什么编程语言来完成操作系统实验。你可以用任何你喜欢的编程语言来实现操作系统。我们推荐的编程语言是Rust。

.. note::

   目前常见的操作系统内核都是基于C语言的，为何要推荐Rust语言？
   
   - 没错，C语言就是为写UNIX而诞生的。Dennis Ritchie和KenThompson还没有渴望计算机帮助完成更复杂的业务逻辑,只是希望用一种更加简单的方式抽象出计算机的行为,便于编写操作系统,最终的结果就是C语言。
   - C语言的指针的天使与魔鬼，且C缺少有效的并发支持，导致内存和并发漏洞成为当前操作系统的噩梦。
   - 从某种角度上看，Rust的目标是解决C的短板，取代C。所以用Rust写OS具有很好的开发和运行的体验。
   - 用Rust写OS的代价仅仅是学会用Rust编程。



