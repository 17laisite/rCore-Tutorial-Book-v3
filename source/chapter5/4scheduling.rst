进程调度
============================================


本节导读
--------------------------------------------

当处理器只有一个，而在内存中存在多个程序/任务/进程的时候，它们就会共享处理器资源。而操作系统就要负责让它们能够高效合理地共享处理器资源，这就引入了调度（scheduling）这个概念。进程调度就是操作系统进程管理的重要组成部分。事实上，在计算机出现之前，调度的概念和应用就出现在人类的生活、工作和生产环境中了，如汽车装配线调度、工厂作业车间调度等。调度的一个一般定义是：在一定的约束条件下，把有限的资源在时间上分配给若干个任务，以满足或优化一个或多个性能指标。对于计算机系统而言，就是在一台计算机中的内存中运行了多个进程，操作系统把有限的处理器在时间上分配给各个进程，以满足或优化进程执行的性能指标。所以本节的核心是：操作系统如何通过进程调度来提高进程的性能。

那操作系统需要了解和的的关键问题就是：计算机中运行进程的约束条件是啥？性能指标是啥？如何设计和评价调度策略？


回顾一下
---------------------------------------------

已实现操作系统中的调度
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

目前已经实现的操作系统都比较简单，只保留了体现操作系统核心思想的部分。不过实际上，从我们设计实现的面向批处理的“邓式鱼” 操作系统开始，我们就有了非常简单的调度雏形。“邓式鱼” 操作系统只是把程序按提交或排名的先后顺序，一个一个地加载到内存中执行，一个程序执行完毕后，再执行下一个程序，这就是一种调度，只是效率很低。在后续面向多道程序的“锯齿螈”操作系统进化到“始初龙”操作系统后，运行的程序称为任务，并且任务可以主动放弃处理器，让操作系统能够按任务排队顺序选择下一个就绪的任务去执行。从调度策略上看，这几种操作系统采用的都可看作是一种先来先服务的调度策略，实现起来非常简单。

而后续面向分时多任务系统的“腔骨龙”操作系统为了公平和执行效率起见，给每个任务分配了时间片，任务执行消耗完时间片后，操作系统就可以抢占正在执行的任务，把处理器分配给其他任务执行。这就是一种基于时间片的轮转调度策略。再之后实现的操作系统都采用了这种调度策略。

计算机发展历史中的调度
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在早期以纸带、卡片或磁带作为程序/数据输入的批处理系统时代，操作系统的调度很简单，只需依次加载并运行每一个作业即可。操作系统不需要考虑多用户，分时复用等情况，能让程序正常运行就很不错了。而到了多道程序系统时代，内存中有了多个程序，而程序是属于不同用户的，处理器是大家都想占用的宝贵资源，用户不得不花时间等待，操作系统需要想方设法地减少用户的等待时间，这样调度算法就要复杂一些。而分时多任务系统出现后，目标不同的批处理任务和交互任务都需要得到服务，操作系统在调度上不得不花费更大心思来应对不同性能指标的任务要求。当然，这一阶段的计算机系统还是以昂贵的大型机/小型机为主，服务的用户主要来源于科学计算和商业处理等科研机构和公司，他们希望把计算机系统的性能榨干，这样才对得起他们付出的大量金钱。

当发展到了个人计算机时代，情况发生了变化，计算机的价格大幅下降，而且个人计算机的多数程序受到的是个人用户当前的键盘/鼠标/图形显示等I/O速率的限制，而不是CPU处理速率的限制。这样造成的结果是，操作系统的调度功能在相对简单的个人计算机上的作用并不显著。

随着网络的发展，以数据中心为代表的网络服务器计算机系统改变了我们的生活，多核处理器已经成为主流，各种日常应用（搜索、网络社交、网络游戏等）会消耗数据中心中大量的处理器资源和网络/存储资源，多个进程经常会竞争处理器，因此操作系统的调度功能再一次变得至关重要，且要应对更加复杂多样的应用需求和硬件环境。

当移动互联网成为基础设施，移动终端越来越普及时，大家几乎人手一台智能手机、智能平板或智能手表等，人们关注的除了流畅地执行各种应用外，还希望这些移动终端能够长时间使用。这使得除了增加电池容量外，操作系统的调度功能还需在应用不必运行时，让它们尽量休眠，关闭可暂时不用的外设，减少电量的消耗。可以看到，随着计算机系统的发展，应用需求的变化，都会对操作系统调度功能提出新的需求。

目前我们实现的操作系统调度策略还太简单，不一定适合更加实际的情况。接下来，我们将讲述针对计算机约束条件以及进程的性能指标，如何设计合理的调度策略？我们会分析在不同的计算机系统下，操作系统中典型的调度基本思路和调度策略。


批处理系统的调度
----------------------------------

在设计具体的调度策略之前，需要了解操作系统和应用的计算机系统和运行环境，对应用的特点和它期望的性能指标也要清楚。我们先看看批处理系统下的应用如何进行调度。

约束条件
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

批处理系统中的进程有如下一些约束/前提条件：

1. 每个进程同时到达。
2. 每个进程的执行时间相同。
3. 进程的执行时间是已知的。
4. 进程在整个执行过程期间不执行I/O操作。
5. 进程在执行过程中不会被抢占。

注意，我们这里设定的各种条件是可以调整的，即可以进一步简化或更加贴近实际情况，这样可以简化或加强对调度策略的设计。比如，我们可以把条件 2 改变一下：

2. 每个进程的执行时间不同。

性能指标
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

我们还需给出性能指标，用于衡量，比较和评价不同的调度策略。对于批处理系统中的一般应用而言，可以只有一个性能指标：周转时间（turn around time），即进程完成时间与进程到达时间的差值：
    
    T周转时间 = T完成时间−T到达时间

由于前提条件1 明确指出所有进程在同一时间到达，那么T到达时间= 0，因此T周转时间= T完成时间。除了总的周转时间，我们还需要关注平均周转时间这样的统计值：
    
    T平均周转时间 =  T周转时间 / 就绪进程个数

对于单个进程而言，平均周转时间是一个更值得关注的性能指标。



先来先服务
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

先来先服务（first-come first-severd，也称First-in first-out，先进先出）调度策略的基本思路就是按进程请求处理器的先后顺序来使用处理器。在具体实现上，操作系统建立一个就绪队列，当一个应用进入被加载，并创建为进程进入就绪态后，就按先后顺序放入就绪队列尾；操作系统从就绪队列头取出进程来执行。操作系统不会主动打断进程的运行。当正在运行的进程主动放弃处理器，操作系统会把该进程放到就绪队列末尾，并从就绪队列头取出新进程执行；当正在运行的进程阻塞时，操作系统会把该进程放到阻塞队列中，并从就绪队列头取出新进程执行；当阻塞进程转为就绪进程后，操作系统
会把该进程放到就绪队列末尾。

该调度策略的优点是简单，容易实现。对于满足1~6的约束条件的执行环境，用这个调度策略的平均周转时间性能指标也很好。如果在一个在较长的时间段内，每个进程都能结束，那么公平性这个性能指标也是能得到保证的。

但满足1~5的约束条件的执行环境太简化和理想化了，我们让约束条件更贴近时间情况，改变其中第2点：

2. 每个进程的执行时间不同。

那么平均周转时间的结果就可能不那么让人满意了。加入有两个个进程PA、PB，它们大致同时到达，但PA稍微快一点，进程PA执行时间为100，进程PB的执行时间为20。如果操作系统采用先来先服务的调度策略，进程的平均周转时间为：

    (100+120)/2 = 110

但如果操作系统先调度进程PB，那么进程的平均周转时间为：

    (20+120)/2 = 70

可以看到，如果采用先来先服务调度策略，执行时间短的进程（简称短进程）可被排在执行时间长的进程（长进程）后面，导致进程的平均周转时间变长。    


最短作业优先
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果约束条件2是 "每个进程的执行时间不同" ， 那么为应对短进程不得不等长进程结束后才能运行的问题，可以比较简单地想到一个方法：优先让短进程执行。这就是最短作业优先（Shortest Job First，简称SJF）调度策略。其实上面让PB先执行的调度方法，就是采用了最短作业优先策略。

在修改了第二点的1~5约束条件下，如果我们把平均周转时间作为唯一的性能指标，那么SJF是一个最优调度算法。这可以用数学方法进行证明，不难。如果有同学感兴趣，可以试试。

在一定约束条件下，SJF调度策略在理论上表现很不错。在实现上，需要对处于就绪队列上的进程按执行时间进行排序，这会引入一定的开销。而且如果进一步放宽约束，贴近实际情况，SJF就会显现出它的不足。如果我们放宽第一点：

1. 每个进程可以在不同时间到达。

那么可能会发生一种情况，当前正在运行的进程还需 k 执行时间才能完成，这时来了一个执行时间为 h 的进程，且 h < K ，但根据约束条件5，操作系统不能强制切换正在运行的进程。所以，在这种情况下，最短作业优先的含义就不是那么确切了，而且在理论上，SJF也就不是最优调度算法了。

例如，操作系统采用SJF调度策略（不支持抢占进程），有两个进程，PA在时间0到达，执行时间为100， PB在时间20到达，执行时间为20，那么周转时间为 

  (100 -0) + (120-20) = 200

平均周转时间为 100 。


交互式系统的调度
----------------------------------

由于操作系统在不断发展，从不能抢占任务执行的批处理操作系统，多道程序操作系统进化到可抢占任务的分时多任务操作系统，对交互性根据友好，使得约束条件进一步放宽，计算机系统可以看成是一种交互式系统。

约束条件
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

交互式系统中的进程有如下一些约束/前提条件：

1. 每个进程可不同时间到达。
2. 每个进程的执行时间不同。
3. 进程的执行时间是已知的。
4. 进程在整个执行过程期间不执行I/O操作。
5. 进程在执行过程中会被抢占。

相对于批处理操作系统，条件5发生了改变。而且我们也会进一步放宽约束条件，让它们贴近实际情况。

性能指标
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

操作系统支持任务/进程被抢占的一个重要目标是提高用户的交互性体验，用户希望计算机系统能及时响应他发出的请求，而平均周转时间不足以体现用户的交互性。所以，我们需要定义新的性能指标 -- 响应时间（response time）：

    T响应时间 = T首次执行 - T到达时间

而对应的平均响应时间是：

   T平均响应时间 = T响应时间 / 就绪进程个数

例如，操作系统采用SJF调度策略（不支持抢占进程），有两个进程，PA在时间0到达，执行时间为100， PB在时间20到达，执行时间为20，那么PA的响应时间为0，PB为80，平均响应时间为 40 。

最短完成时间优先（STCF）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

由于约束条件5表示了操作系统允许抢占，那么我们就可以实现一种支持进程抢占的改进型SJF调度策略，即最短完成时间优先（Shortest Time to Complet First）调度策略。

基于前述的例子，操作系统采用STCF调度策略，有两个进程，PA在时间0到达，执行时间为100， PB在时间20到达，执行时间为20，那么周转时间为 

  （120 - 0) + (40 - 20) = 140

平均周转时间为 70 。可以看到，相对于SJF调度策略，在周转时间这个性能指标上得到了改善。

但对于响应时间而言，可能就不是这么好了。考虑一个例子，有两个用户发出了执行两个进程的请求，且两个进程大约同时到达，PA和PB的执行时间都为20s(秒)。我们发现，无论操作系统采用FIFO/SJF/STCF中的哪一种调度策略，某一个用户不得不等待20s才能让他的进程开始执行，这是一个非常不好的交互体验。从性能指标上看，响应时间这一项指标比较差。
这就引入了新的问题：操作系统如何支持看重响应时间这一指标的应用程序？

轮转调度
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果操作系统分给每个运行的进程的运行时间是一个足够小的时间片（time slice，quantum），时间片一到，就抢占当前进程并切换到另外一个进程执行。这样进程以时间片为单位轮流占用处理器执行。对于交互式进程而言，就有比较大的机会在较短的时间内执行，从而有助于减少响应时间。这种调度策略称为轮转（Round-Robin，简称RR）调度，即基本思路就是从就绪队列头取出一个进程，让它运行一个时间片，然后把它放回到队列尾，再从队列头取下一个进程执行，周而复始。

在具体实现上，需要考虑时间片的大小，一般时间片的大小会设置为时钟中断的时间间隔的整数倍。比如，时钟中断间隔为1ms，时间片可设置为10ms，两个用户发出了执行两个进程的请求，且两个进程大约同时到达，PA和PB的执行时间都为20s(即20,000ms)。如果采用轮转调度，那么进程的响应时间为:

    0+10 = 10ms

平均响应时间为：
    
    (0+10)/2 = 5ms

这两个值都远小于采用之前介绍的三种调度策略的结果。 这看起来不错，而且，直观上可以进一步发现，如果我们进一步减少时间片的大小，那么采用轮转调度策略会得到更好的响应时间。但其实这是有潜在问题的，因为每次进程切换是有切换代价的，参考之前介绍的进程切换的实现，可以看到，进程切换涉及多个寄存器的保存和回复操作，页表的切换操作等。如果进程切换的时间开销是0.5ms，时间片设置为1ms，那么会有大约50%的时间用于进程切换，这样进程实际的整体执行时间就大大减少了。所以，我们需要通过在响应时间和进程切换开销之间进行权衡。不能把时间片设置得太小，且让响应时间在用户可以接受的范围内。

看来轮转调度对于响应时间这个指标很友好。但如果用户也要考虑周转时间这个指标，那轮转调度就变得不行了。还是上面的例子，我们可以看到，PA和PB两个进程几乎都在40s左右才结束，这意味着平均周转时间为：

    (40+40)/2 = 40s

这大于基于SJF的平均周转时间：

    ((20-0) + (40-0))/2 = 30s

如果活跃进程的数量增加，我们会发现轮转调度的平均周转时间会进一步加强。也许有同学会说，那我们可以通过调整时间片，把时间片拉长，这样就会减少平均周转时间了。但这样又会把响应时间也给增大了。而且如果把时间片无限拉长，轮转调度就变成了FCFS调度了。

到目前为止，我们看到以SJF为代表的调度策略对周转时间这个性能指标很友好，而以轮转调度为代表的调度策略对响应时间这个性能指标很友好。但鱼和熊掌难以兼得。

通用计算机系统的调度
----------------------------------

个人计算机和互联网的发展推动了计算机的广泛使用，并出现了新的特点，内存越来越大，各种I/O设备成为计算机系统的基本配置，一般用户经常和随时使用交互式应用（如字处理、上网等），驻留在内存中的应用越来越多，应用的启动时间和执行时间无法提前知道。而且很多情况下，处理器大部分时间处于空闲状态，在等待用户或其它各种外设的输入输出操作。

约束条件
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

这样，我们的约束条件也随之发生了新的变化：

1. 每个进程可不同时间到达。
2. 每个进程的执行时间不同。
3. 进程的启动时间和执行时间是未知的。
4. 进程在整个执行过程期间会执行I/O操作。
5. 进程在执行过程中会被抢占。

可以看到，其中的第3和第4点改变了，导致进程的特点也发生了变化。有些进程为I/O密集型的进程，大多数时间用于等待外设I/O操作的完成，需要进程能及时响应。有些进程是CPU密集型的，大部分时间占用处理器进行各种计算，不需要及时响应。还有一类混合型特点的进程，它在不同的执行阶段有I/O密集型或CPU密集型的特点。这使得我们的调度策略需要能够根据进程的动态运行状态进行调整，以应对各种复杂的情况。

性能指标
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果把各个进程运行时间的公平性考虑也作为性能指标，那么我们就需要定义何为公平。我们先给出一个公平的描述性定义：在一个时间段内，操作系统对每个个处于就绪状态的进程均匀分配占用处理器的时间。

这里需要注意，为了提高一个性能指标，可能会以牺牲其他性能指标作为代价。所以，调度策略需要综合考虑和权衡各个性能指标。在其中找到一个折衷或者平衡。


多级反馈队列调度
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在无法提前知道进程执行时间的前提下，如何设计一个能同时减少响应时间和周转时间的调度策略是一个挑战。不过计算机科学家早就对此进行深入分析并提出了了解决方案。在1962年，MIT的计算机系教授Fernando Jose Corbato(1990年图灵奖获得者)首次提出多级反馈队列（Multi-level Feedback Queue，简称MLFQ）调度策略，并用于当时的CTSS（兼容时分共享系统）操作系统中。

.. chyyuu Fernando Jose Corbato  https://baike.baidu.com/item/%E8%B4%B9%E5%B0%94%E5%8D%97%E5%A4%9A%C2%B7%E4%BD%95%E5%A1%9E%C2%B7%E7%A7%91%E5%B0%94%E5%B7%B4%E6%89%98/23620625

Corbato教授的思路很巧妙，用四个字来总结，就是 **以史为鉴** 。即根据进程过去一段的执行特征来预测其未来一段时间的执行情况，并以此假设为依据来动态设置进程的优先级，调度子系统选择优先级最高的进程执行。这里可以看出，进程有了优先级的属性，而且进程的优先级是可以根据过去行为的反馈来动态调整的，不同优先级的进程位于不同的就绪队列中。

接下来，我们逐步深入分析多级反馈队列调度的设计思想。

多级无反馈队列
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

MLFQ调度策略的关键在于如何设置优先级。一旦设置进程的好优先级，MLFQ总是优先执行唯有高优先级就绪队列中的进程。对于挂在同一优先级就绪队列中的进程，采用轮转调度策略。

先考虑简单情况下，如果我们提前知道某些进程是I/O密集型的，某些进程是CPU密集型的，那么我们可以给I/O密集型设置高优先级，而CPU密集型进程设置低优先级。这样就绪队列就变成了两个，一个包含I/O密集型进程的高优先级队列，一个是处理器密集型的低优先级队列。

那我们如何调度呢？MLFQ调度策略是先查看高优先级队列中是否有就绪进程，如果有，就执行它，然后基于时间片进行轮转。由于位于此高优先级队列中的进程都是I/O密集型进程，所以它们很快就会处于阻塞状态，等待I/O设备的操作完成，这就会导致高优先级队列中没有就绪进程。

在高优先级队列没有就绪进程的情况下，MLFQ调度策略就会从低优先级队列中选择CPU密集型就绪进程，同样按照时间片轮转的方式进行调度。如果在CPU密集型进程执行过程中，某个I/O密集型进程所等待的I/O设备的操作完成了，那么操作系统会打断CPU密集型进程的执行，以及时响应该中断，并让此I/O密集型进程从阻塞状态变成就绪态，重新接入到高优先级队列的尾部。这时调度子系统会优先选择高优先级队列中的进程执行，从而抢占了CPU密集型进程的执行。

这样，我们就得到了MLFQ的基本设计规则：

1. 如果进程PA的优先级 > PB的优先级，抢占运行PA。
2. 如果进程PA的优先级 = PB的优先级，轮转运行PA和PB。

单级反馈队列
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

多级反馈队列
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


比例份额调度
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



实时计算机系统的调度
----------------------------------

约束条件
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

性能指标
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RM调度
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

EDF调度
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

多处理器计算机系统的调度
----------------------------------

约束条件
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

性能指标
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

单队列调度
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

多队列调度
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


小结
----------------------------------



