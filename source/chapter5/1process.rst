进程概念及重要系统调用
================================================

本节导读
-------------------------

本节的内容有：

- 介绍进程的概念以及它和一些其他相近的概念的比较；
- 从应用开发者或是用户的角度介绍我们的实现中一种简单的类 Unix 进程模型；
- 介绍三个最重要的进程相关的系统调用并给出一些例子。

进程概念
-------------------------

.. _term-process:

在本章的引言中，出于方便应用开发和使得应用功能更加强大的目标，我们引入了进程的概念。所谓 **进程** (Process) ，就是指 **正在执行的程序** 。尽管说起来很容易，但事实上进程是一个内涵相当丰富且深刻、难以从单个角度解释清楚的抽象概念。我们可以先试着从动态和静态的角度来进行初步的思考。我们知道，当一个应用被成功构建之后，它会从源代码变为某种格式的可执行文件，如果将其展开的话可以在它的内存布局中看到若干个功能迥异的逻辑段。但仅是如此的话，它也就只是某种格式特殊的、被 **静态** 归档到存储器上的一个文件而已。

然而，可执行文件与其他类型文件的决定性的不同就在于它可以被内核加载并执行。这一过程自然是不能凭空进行的，而是需要占据某些真实的硬件资源。例如，可执行文件一定需要被加载到物理内存的某些区域中才能执行，另外还可能需要预留一些可执行文件内存布局中未规划的区域（比如栈），这就会消耗掉部分内存空间；在执行的时候需要占据一个 CPU 的全部硬件资源，我们之前介绍过的有通用寄存器（其中程序计数器 pc 和栈指针 sp 两个意义尤其重大）、CSR 、各级 cache 、TLB 等。

打一个比方，可执行文件本身可以看成一张编译器解析源代码之后总结出的一张记载如何利用各种硬件资源进行一轮生产流程的 **蓝图** 。而内核的一大功能便是作为一个硬件资源管理器，它可以随时启动一轮生产流程（即执行任意一个应用），这需要选中一张蓝图（此时确定执行哪个可执行文件），接下来就需要内核按照蓝图上所记载的对资源的需求来对应的将各类资源分配给它让这轮生产流程得以顺利进行。当按照蓝图上的记载生产流程完成（应用退出）之后，内核还需要将对应的硬件资源回收以便后续的重复利用。

因此，进程就是选取某个可执行文件并对其进行一次动态执行的过程。相比可执行文件，它的动态性主要体现在：

1. 它是一个过程，从时间上来看有开始也有结束；
2. 在该过程中对于可执行文件中给出的需求要相应对 **硬件资源** 进行 **动态绑定** 。

这里需要指出的是，两个进程可以选择同一个可执行文件执行，然而它们却是截然不同的进程：它们的启动时间、占据的硬件资源、输入数据均有可能是不同的，这些条件均会导致它们是不一样的执行过程。在某些情况下，我们可以看到它们的输出是不同的——这是其中一种可能的直观表象。

在内核中，需要有一个进程管理器，在其中记录每个进程对资源的占用情况，这是内核作为一个硬件资源管理器所必须要做到的。进程管理器通常需要管理多个进程，因为如果同一时间只有一个进程的话，就可以简单的将所有的硬件资源都交给该进程，同时内核也会像第一章《RV64 裸机应用》那样退化成一个函数库。

本节接下来主要站在应用开发者和用户的角度来介绍如何理解进程概念并基于它编写应用程序。

.. warning::

    **TODO：进程、线程与协程**

.. warning::

    **TODO：章节设计：为何要在这里才引入进程概念**


进程模型与重要系统调用
------------------------------------------------------------

目前，我们只介绍一种我们的内核实现中所采用的一种非常简单的进程模型。前面我们并没有给出进程需要管理哪些类型的硬件资源或是如何管理，这取决于内核提供给应用的接口以及内核的具体实现。由于我们实现的进程模型需要支持一些重要的系统调用，它需要建立在地址空间抽象之上：每个进程都需要管理一个地址空间，它涵盖了它选择的可执行文件的内存布局，还包含一些其他的逻辑段。

fork 系统调用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. _term-pid:
.. _term-initial-process:

系统中同一时间存在的每个进程都被一个不同的 **进程标识符** (PID, Process Identifier) 所标识。在内核初始化完毕之后会创建一个进程——即 **初始进程** (Initial Process) ，它是目前在内核中以硬编码方式创建的唯一一个进程。其他所有的进程都是通过一个名为 ``fork`` 的系统调用来创建的。

.. code-block:: rust

    /// 功能：当前进程 fork 出来一个子进程。
    /// 返回值：对于子进程返回 0，对于当前进程则返回子进程的 PID 。
    /// syscall ID：220
    pub fn sys_fork() -> isize;

调用 ``fork`` 之后，内核会创建一个新进程，这个进程和调用 ``fork`` 的进程在返回用户态那一瞬间几乎处于相同的状态：这意味着它们用户态的各代码、堆栈及其他数据段的内容完全相同，但是它们是被放在两个独立的地址空间中的，因此新进程的地址空间需要从原有进程的地址空间完整拷贝一份。通用寄存器也几乎完全相同。例如， pc 相同意味着两个进程会从同一位置的一条相同指令（我们知道其上一条指令一定是用于系统调用的 ecall 指令）开始向下执行， sp 相同则意味着两个进程的用户栈在各自的地址空间中的位置相同。其余的寄存器相同则确保了二者回到了相同的执行流状态。

.. _term-child-process:
.. _term-parent-process:

但是唯有用来保存 ``fork`` 系统调用返回值的 a0 寄存器（由 RV64 调用规范）的值是不同的。这区分了两个进程：原进程的返回值为新创建进程的 PID ，而新创建进程的返回值为 0 。由于新的进程是原进程主动调用 ``fork`` 衍生出来的，我们称新进程为原进程的 **子进程** (Child Process) ，相对的原进程则被称为新进程的 **父进程** (Parent Process) 。这样二者就建立了一种父子关系。注意到每个进程可能有多个子进程，但最多只能有一个父进程，于是所有进程可以被组织成一颗有根树，其根节点正是初始进程。

相比创建一个进程， ``fork`` 更重要的功能是建立一对新的父子关系。在我们的进程模型中，父进程和子进程之间的联系更为紧密，它们更容易进行合作或通信，而且一些重要的机制也需要在它们之间才能展开。

waitpid 系统调用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. _term-zombie-process:

当一个进程通过 ``exit`` 系统调用退出之后，它所占用的资源并不能够立即全部回收。比如该进程的内核栈目前就正用来进行系统调用处理，如果将它被放置在的物理页帧回收的话可能会导致系统调用不能正常处理。对于这种问题，一种典型的做法是当进程退出的时候内核立即回收一部分资源并将该进程标记为 **僵尸进程** (Zombie Process) 。之后，由该进程的父进程通过一个名为 ``waitpid`` 的系统调用来收集该进程的返回状态并回收掉它所占据的全部资源。系统调用 ``waitpid`` 的原型如下：

.. code-block:: rust

    /// 功能：当前进程等待一个子进程变为僵尸进程，回收其全部资源并收集其返回值。
    /// 参数：pid 表示要等待的子进程的进程 ID，如果为 -1 的话表示等待任意一个子进程；
    /// exit_code 表示保存子进程返回值的地址，如果这个地址为 0 的话表示不必保存。
    /// 返回值：如果要等待的子进程不存在则返回 -1；否则如果要等待的子进程均为结束则返回 -2；
    /// 否则返回结束的子进程的进程 ID。
    /// syscall ID：260
    pub fn sys_waitpid(pid: isize, exit_code: *mut i32) -> isize;

一般情况下一个进程要负责通过 ``waitpid`` 系统调用来等待所有它 ``fork`` 出来的子进程结束并回收掉它们占据的资源，这也是父子进程间的一种同步手段。但这并不是必须的：如果一个进程先于它的子进程结束，在它退出的时候，它的所有子进程将成为进程树的根节点——初始进程的子进程，同时这些子进程的父进程也会变成初始进程。这之后，这些子进程的资源就由初始进程负责回收了，这也是初始进程很重要的一个用途。后面我们会介绍初始进程是如何实现的。

exec 系统调用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果仅有 ``fork`` 的话，那么所有的进程都只能和初始进程一样执行同样的可执行文件，这显然是远远不够的。于是我们还需要引入 ``exec`` 系统调用来执行我们希望的可执行文件：

.. code-block:: rust

    /// 功能：将当前进程的地址空间清空并加载一个特定的可执行文件，返回用户态后开始它的执行。
    /// 参数：path 给出了要加载的可执行文件的名字；
    /// 返回值：如果出错的话（如找不到名字相符的可执行文件）则返回 -1，否则不应该返回。
    /// syscall ID：221
    pub fn sys_exec(path: &str) -> isize;


这样，利用 ``fork`` 和 ``exec`` 的组合，我们很容易在一个进程内 ``fork`` 出一个子进程并执行一个特定的可执行文件。

.. _term-redirection:

.. note::

    **为何执行应用要通过两个系统调用而不是一个？**

    读者可能会有疑问，要达成执行应用的目标，我们为什么不设计一个系统调用接口同时实现创建一个新进程并加载给定的可执行文件两种功能？因为目前使用 ``fork`` 和 ``exec`` 的组合的话，这里 ``fork`` 出来的进程仅仅是为了 ``exec`` ，它 ``fork`` 的时候地址空间拷贝的开销就被完全浪费掉了，而在后续清空地址空间的时候还会产生一些资源回收的额外开销。然而这样做是经过实践考验的——事实上 ``fork`` 和 ``exec`` 是功能极其强大的经典组合。原因就在于：这些开销能够通过一些手段大幅降低，且拆分为两个系统调用大大增加了灵活性，如可以支持 **重定向** (Redirection) 等功能。


应用程序示例
-----------------------------------------------

我们刚刚介绍了 ``fork/waitpid/exec`` 三个重要系统调用，借助它们我们可以开发功能更为强大的应用程序。下面我们通过进程模型中两个重要应用程序——即初始进程和用户终端的开发过程来展示这些重要系统调用的使用方法。

系统调用封装
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

读者可以在 ``user/src/syscall.rs`` 中看到以 ``sys_*`` 开头的系统调用的函数原型，它们后续还会在 ``user/src/lib.rs`` 中被封装成方便应用程序使用的形式。如 ``sys_fork`` 被封装成 ``fork`` ，而 ``sys_exec`` 被封装成 ``exec`` 。这里值得一提的是 ``sys_waitpid`` 被封装成两个不同的 API ：

.. code-block:: rust
    :linenos:

    // user/src/lib.rs

    pub fn wait(exit_code: &mut i32) -> isize {
        loop {
            match sys_waitpid(-1, exit_code as *mut _) {
                -2 => { yield_(); }
                // -1 or a real pid
                exit_pid => return exit_pid,
            }
        }
    }

    pub fn waitpid(pid: usize, exit_code: &mut i32) -> isize {
        loop {
            match sys_waitpid(pid as isize, exit_code as *mut _) {
                -2 => { yield_(); }
                // -1 or a real pid
                exit_pid => return exit_pid,
            }
        }
    }

其中 ``wait`` 表示等待任意一个子进程结束，根据 ``sys_waitpid`` 的约定它需要传的 pid 参数为 ``-1`` ；而 ``waitpid`` 则等待一个 PID 固定的子进程结束。在具体实现方面，我们看到当 ``sys_waitpid`` 返回值为 ``-2`` ，即要等待的子进程存在但它却尚未退出的时候，我们调用 ``yield_`` 主动交出 CPU 使用权，待下次 CPU 使用权被内核交还给它的时候再次调用 ``sys_waitpid`` 查看要等待的子进程是否退出。这样做可以减小 CPU 资源的浪费。

目前的实现风格是尽可能简化内核，因此 ``sys_waitpid`` 是立即返回的，即它的返回值只能给出返回这一时刻的状态。如果这一时刻要等待的子进程还尚未结束，那么也只能如实向应用报告这一结果。于是用户库 ``user_lib`` 就需要负责对返回状态进行监控，因此它里面便需要进行循环。在后面的实现中，我们会将  ``sys_waitpid`` 的内核实现设计为 **阻塞** 的，也即直到得到一个确切的结果位置都停在内核内，也就意味着内核返回给应用的结果可以直接使用。那是 ``wait`` 和 ``waitpid`` 两个 API 的实现便会更加简单。

初始进程 initproc
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

我们首先来看初始进程是如何实现的：

.. code-block:: rust
    :linenos:

    // user/src/bin/initproc.rs

    #![no_std]
    #![no_main]

    #[macro_use]
    extern crate user_lib;

    use user_lib::{
        fork,
        wait,
        exec,
        yield_,
    };

    #[no_mangle]
    fn main() -> i32 {
        if fork() == 0 {
            exec("user_shell\0");
        } else {
            loop {
                let mut exit_code: i32 = 0;
                let pid = wait(&mut exit_code);
                if pid == -1 {
                    yield_();
                    continue;
                }
                println!(
                    "[initproc] Released a zombie process, pid={}, exit_code={}",
                    pid,
                    exit_code,
                );
            }
        }
        0
    }

- 第 19 行为 ``fork`` 返回值为 0 的分支，表示子进程，此行直接通过 ``exec`` 执行用户终端 ``user_shell`` ，注意我们需要在字符串末尾手动加入 ``\0`` ，因为 Rust 再将这些字符串连接到只读数据段的时候不会插入 ``\0`` 。
- 第 21 行开始则为返回值不为 0 的分支，表示调用 ``fork`` 的初始进程自身。可以看到它在不断循环调用 ``wait`` 来等待那些被移交到它下面的子进程并回收它们占据的资源。如果回收成功的话则会打印一条报告信息给出被回收子进程的 PID 和返回值；否则就 ``yield_`` 交出 CPU 资源并在下次轮到它执行的时候再回收看看。这也可以看出，初始进程对于资源的回收并不算及时，但是对于已经退出的僵尸进程，初始进程最终总能够成功回收它们的资源。 


用户终端
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
