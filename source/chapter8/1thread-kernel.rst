内核态的线程管理
=========================================

.. toctree::
   :hidden:
   :maxdepth: 5


本节导读
-----------------------------------------

在上一节介绍了如何在用户态实现对多线程的管理，让同学对多线程的实际运行机制：创建线程、切换线程等有了一个比较全面的认识。由于在用户态进行线程管理，带了的一个潜在不足是没法让线程管理运行时直接切换线程，只能等当前运行的线程主动让出处理器使用权后，线程管理运行时才能切换检查。在上一章的操作系统运行在内核态，如果扩展一下对线程的管理，那就可以基于时钟中断来直接打断当前用户态线程的运行，实现对线程的调度和切换等。

本节参考上一节的用户态线程管理机制，结合上一章的操作系统实现：具有UNIX操作系统基本功能的 “霸王龙” 操作系统，进化为更加迅捷的 “达科塔盗龙” [#dak]_ 操作系统，我们首先分析如何扩展现有的进程，以支持线程管理。然后设计线程的总体结构、管理线程执行的线程控制块数据结构、以及对线程管理相关的重要函数：线程创建和线程切换。并最终合并到现有的进程管理机制中。本节的内容能帮助我们理解进程和线程的关系，二者在设计思想与具体实现上的差异，为后续支持各种并发机制打下基础。


.. note::

   为何要在这里才引入线程

   学生对进程有一定了解后，再来理解线程也会更加容易。因为从对程序执行的控制流进行调度和切换上看，本章讲解的线程调度与切换操作是之前讲解的进程调度与切换的一个子集。另外，在这里引入线程的一个重要原因是为了便于引入并发。没在进程阶段引入并发这个专题的原因是，进程主要的目的是隔离，而线程的引入强调了共享，即属于同一进程的多个线程可共享进程的资源，这样就必须要解决同步问题了。


线程概念
---------------------------------------------

这里会结合与进程的比较来说明线程的概念。到本章之前，我们看到了进程这一抽象，操作系统让进程拥有相互隔离的虚拟的地址空间，让进程感到在独占一个虚拟的处理器。其实这只是操作系统通过时分复用和空分复用技术来让每个进程复用有限的物理内存和物理CPU。而线程是在进程内中的一个新的抽象。在没有线程之前，一个进程在一个时刻只有一个执行点（即程序计数器 （PC）寄存器保存的要执行指令的指针）。但线程的引入把进程内的这个单一执行点给扩展为多个执行点，即在进程中存在多个线程，每个线程都有一个执行点。而且这些线程共享进程的地址空间，所以可以不必采用相对比较复杂的IPC机制（一般需要内核的介入），而可以很方便地直接访问进程内的数据。

在线程的具体运行过程中，需要有程序计数器寄存器来记录当前的执行位置，需要有一组通用寄存器记录当前的指令的操作数据，需要有一个栈来保存线程执行过程的函数调用栈和局部变量等，这就形成了线程上下文的主体部分。这样如果两个线程运行在一个处理器上，就需要采用类似两个进程运行在一个处理器上的调度/切换管理机制，即需要在一定时刻进行线程切换，并进行线程上下文的保存与恢复。这样在一个进程中的多线程可以独立运行，取代了进程，成为操作系统调度的基本单位。

由于把进程的结构进行了细化，通过线程来表示对处理器的虚拟化，使得进程成为了管理线程的容器。在进程中的线程没有父子关系，大家都是兄弟，但还是有个老大。这个代表老大的线程其实就是创建进程（比如通过 ``fork`` 系统调用创建进程）时，建立的第一个线程，它的线程标识符（TID）为 ``0`` 。




通用操作系统多线程应用程序示例
-----------------------------------------------------

在Rust应用开发中，有比较完善的线程API来支持多线程应用的开发，当然这需要底层的操作系统（如Linux）的支持。Rust 语言标准库中的 std::thread 模块提供很很多方法用于创建线程、管理线程和结束线程，以支持多线程编程。一些基本的线程方法如下：

- spawn()：创建一个新线程。
- join()：把子线程加入主线程等待队列，等待子线程结束。

下面是一个Rust线程的例子：

.. code-block:: rust
   :linenos:

   // thread.rs

   use std::thread;

   fn mythread(args: i64) -> i64 {
       println!("{}", args);
       return args + 1;
   }

   fn main() {
       let handle = thread::spawn(|| mythread(100));
       let rvalue = handle.join().unwrap();
       println!("{}", rvalue);
   }

如果编译执行上述程序，可以看到在主线程创建了子线程后，讲调用 `join()` 函数等待子线程结束；而子线程 `mythread` 打印 `arg` 参数并返回 `arg+` ；主线程等待并获得子线程的返回值后，打印出返回值，然后结束应用进程。

.. code-block:: console

   $rustc thread.rs
   $./thread
     100
     101


为了在 “达科塔盗龙” [#dak]_ 操作系统中实现类似Linux操作系统的多线程支持，我们需要建立精简的线程模型和相关系统调用，并围绕这两点来改进操作系统。

线程模型与重要系统调用
----------------------------------------------

目前，我们只介绍本章实现的内核中采用的一种非常简单的线程模型。这个线程模型有三个运行状态：就绪态、运行态和等待态；共享所属进程的地址空间和其他共享资源（如文件等）；可被操作系统调度来分时占用CPU执行；可以动态创建和退出；可通过系统调用获得操作系统的服务。我们实现的线程模型建立在进程的地址空间抽象之上：每个线程都共享进程的代码段和和可共享的地址空间（如全局数据段、堆等），但有自己的独占的栈。线程模型需要操作系统支持一些重要的系统调用：创建线程、等待子线程结束等，来支持灵活的多线程应用。接下来会介绍这些系统调用的基本功能和设计思路。


线程创建系统调用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在一个进程的运行过程中，进程可以创建多个属于这个进程的线程，每个线程有自己的线程标识符（TID，Thread Identifier）。系统调用 ``thread_create`` 的原型如下：

.. code-block:: rust
   :linenos:

   /// 功能：当前进程创建一个新的线程
   /// 参数：entry 表示线程的入口函数地址
   /// 参数：arg：表示线程的一个参数
   pub fn sys_thread_create(entry: usize, arg: usize) -> isize 

当进程调用 ``thread_create`` 系统调用后，内核会在这个进程内部创建一个新的线程，这个线程能够访问到进程所拥有的代码段，堆和其他数据段。但内核会给这个新线程分配一个它专有的用户态栈，这样每个线程才能相对独立地被调度和执行。相比于创建进程的 ``fork`` 系统调用，创建线程不需要要建立新的地址空间，这是二者之间最大的不同。另外属于同一进程中的线程之间没有父子关系，这一点也与进程不一样。

等待子线程系统调用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

当一个线程执行完代表它的功能后，会通过 ``exit`` 系统调用退出。内核在收到线程发出的 ``exit`` 系统调用后，会回收线程占用的部分资源，即用户态用到的资源，比如用户态的栈，用于系统调用和异常处理的跳板页等。而该线程的内核态用到的资源，比如内核栈等，需要通过进程/主线程调用 ``waittid`` 来回收了，这样整个线程才能被彻底销毁。系统调用 ``waittid`` 的原型如下：



.. code-block:: rust
   :linenos:

   /// 参数：tid表示线程id
   /// 返回值：如果线程不存在，返回-1；如果线程还没退出，返回-2；其他情况下，返回结束线程的退出码
   pub fn sys_waittid(tid: usize) -> i32   


一般情况下进程/主线程要负责通过 ``waittid`` 来等待它创建出来的线程结束并回收它们的资源。但如果进程/主线程先调用了 ``exit`` 系统调用来退出，那么整个进程（包括所属的所有线程）都会立刻退出。


进程相关的系统调用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




应用程序示例
----------------------------------------------


.. code-block:: rust
   :linenos:

   //usr/src/bin/threads.rs

   #![no_std]
   #![no_main]

   #[macro_use]
   extern crate user_lib;
   extern crate alloc;

   use user_lib::{thread_create, waittid, exit};
   use alloc::vec::Vec;

   pub fn thread_a() -> ! {
       for _ in 0..1000 { print!("a"); }
       exit(1)
   }

   pub fn thread_b() -> ! {
       for _ in 0..1000 { print!("b"); }
       exit(2) 
   }

   pub fn thread_c() -> ! {
       for _ in 0..1000 { print!("c"); }
       exit(3)
   }

   #[no_mangle]
   pub fn main() -> i32 {
       let mut v = Vec::new();
       v.push(thread_create(thread_a as usize, 0));
       v.push(thread_create(thread_b as usize, 0));
       v.push(thread_create(thread_c as usize, 0));
       for tid in v.iter() {
           let exit_code = waittid(*tid as usize);
           println!("thread#{} exited with code {}", tid, exit_code);
       }
       println!("main thread exited.");
       0
   }

线程管理的核心数据结构
-----------------------------------------------


线程控制块
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



包含线程的进程控制块
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


线程管理器
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



线程管理机制的设计与实现
-----------------------------------------------


线程创建
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



线程调度与分派
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



线程资源回收
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~







.. [#dak] 一种生存于距今6700万-6500万年前白垩纪晚期的兽脚类驰龙科恐龙，它主打的并不是霸王龙的力量路线，而是利用自己修长的后肢来提高敏捷度和奔跑速度。它全身几乎都长满了羽毛，可能会滑翔或者其他接近飞行行为的行动模式。