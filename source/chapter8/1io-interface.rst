I/O接口
=========================================

本节导读
-----------------------------------------


I/O设备概述
-----------------------------------------

I/O设备从早期相对比较简单的串口、键盘和磁盘等，逐步发展壮大，已经形成种类繁多，不同领域的各种类型的设备大家庭。而各种设备之间功能不一，性能差异巨大，难以统一地进行管理，这是的对应I/O设备的设备驱动程序成为了操作系统中最繁杂的部分。

站在不同的角度会对I/O设备有不同的理解。在硬件工程师看来，I/O设备就是一堆芯片、电线、电源、马达和其他设备的集合体；而软件程序员则主要关注I/O设备为软件提供的接口（interface），即硬件能够接收的命令、能够完成的功能以及能产生的各种错误等。当然，我们的重点放在如何对I/O设备进行编程，而不是其内部的硬件工作原理。然而，对许多I/O设备进行编程还是不可避免地涉及到其内部的硬件细节。

但如果对其发展历史进行深入分析，其实还是能找到其中的共性特征，特征分类和应对的解决方案。


I/O设备的发展历史
~~~~~~~~~~~~~~~~~~~~~~~~~~~

计算机的发展历史可体现为计算机硬件中各个部件的复杂度和集成度的变化发展过程。而在I/O设备变化过程相对比较显著，大致可分为如下阶段：

 1. CPU直接控制I/O设备（如简单的发光二极管等），这在简单的单片机和微处理器控制设备中经常见到。其特点是CPU发出I/O命令或数据，可立刻驱动I/O设备并产生相应的而效果。
   
 2. 在CPU与I/O设备之间增加了一层--I/O控制器（如x86早期的8259）。处理器可以I/O控制器进行编程。其特点是CPU给I/O控制器发出I/O命令或数据，由I/O控制器来直接控制I/O设备。CPU还需通过访问I/O控制器相关寄存器获取I/O设备的状态情况。其特点是CPU需要轮询检查设备情况，对于低速设备（如串口等）而言，高速CPU和低速设备之间是一种串行执行的过程，导致CPU利用率低。 


 3. 为了解决CPU利用率低的问题，I/O控制器扩展了中断机制。CPU发出I/O命令后，无需轮询忙等，可以干其他事情。但外设完成I/O操作后，会通I/O控制器尝试外设中断，让CPU来响应这个中断。由于CPU无需等待外设执行I/O操作，就可在CPU和外设之间形成并行执行的过程，因而提高了CPU的执行效率。


 4. 如果每次中断产生的I/O数据传输量少，那么I/O设备（如硬盘/SSD等）要在短期内传输大量数据就会频繁中断CPU，导致中断处理的总体开销很大。通过DMA（Direct Memory Access，直接内存访问）控制器，可以让外设在CPU没有访问内存的时间段中，以数据块的方式进行外设和内存之间的数据传输，且不需要CPU的干预。这样I/O设备的传输效率就大大提高了。CPU只需在开始传送前发出DMA指令，并在外设结束DMA操作后响应其发出的中断信息即可。
   
 在上述的I/O设备发展过程可以看到，I/O设备可以在没有CPU参与的情况下执行，使得CPU从I/O任务中解脱出来，从而提高了系统的整体性能。在后面的小节中，我们会进一步介绍基于I/O控制器的轮询，中断等方式的设备驱动的设计与实现。

 .. note::

    DMA技术工作流程：

    当CPU想与外设交换一块数据时，它会向DMA控制器发出一条命令。命令内容包括：读或写操作标记，相关的I/O设备的地址，内存的起始地址和长度。然后CPU继续其它工作。DMA控制器收到命令后，会直接从内存中或向内存传送整块数据，这个传输过程不再需要通过CPU进行操作。传送结束后，DMA控制器会通过I/O控制器给CPU发送一个表示DMA操作结束的中断。CPU在收到中断后，知道这次I/O操作完成，可进行后续相关事务的处理。


I/O设备的分类
~~~~~~~~~~~~~~~~~~~~~~~~~~~

I/O设备种类繁多，但我们还是可以从数据传输的特点来给I/O设备进行分类。早期的UNIX把I/O设备分为两类：块设备（block device）和字符设备（character device）。块设备（比如磁盘）把信息存储在固定大小的块中，每个块有独立的地址。块的大小一般在0.5KB至32KB不等。块设备的I/O传输以一个或多个完整的（连续的）块为单位。另一类I/O设备是字符设备，字符设备（如串口，键盘等）以单个字符为单位发送或接收一个字符流。字符设备不需要寻址，只需不同读取/写出I/O设备提供的相关接口即可获得/发出字符信息流。

后来随着网络的普及，又出现了一类设备：网络设备。网络面向报文而不是面向字符流，也不是面向数据块，还具有数据丢失等可靠性问题，因此将网络设备映射为常见的文件比较困难。为此UNIX的早期继承者BSD（Berkeley Software Distribution）提出了socket接口和对应操作，形成了事实上的TCP/IP网络API标准。

再后来随着个人电脑的普及，GUI也越来越被大众熟悉，GPU、声卡、显卡等外设已经很难用上述的三种分类来归类了，这样他们也就形成了它们独立的设备类型。

CPU与I/O设备之间的交互
------------------------------------------

CPU控制与管理I/O设备是通过对I/O控制器发命令或读写特定空间地址来完成的。其处理方式一般有两种，一种是通过特定的I/O指令，如x86中的 ``in`` 和 ``out ``指令，来访问I/O控制器；另外一种是通过内存读写方式，即MMIO(Memory mapping I/O)，把I/O控制器的相关寄存器映射到一段特定的内存空间，通过读写这段特定的内存空间来访问I/O控制器。

第一种通过I/O指令访问的地址空间是I/O地址空间，这个访问内存用到的物理地址空间是两个不同的概念，例如，对于32位的Intel 80386处理器而言，其I/O地址空间为64K，而他的内存所在物理地址空间是4G。这两个空间是相互正交的。

I/O设备想主动通知CPU则主要是通过中断机制来完成的。比如通过设置时钟外设的相关时长寄存器，可以让时钟在规定的时间间隔到达时，产生一个中断，并通过I/O控制器与CPU之间的连接通知到CPU。这样CPU在执行完一条指令后，就能够发现中断的产生，并对外设进行相应的处理。当然，也I/O设备也可被动地“通知”CPU，即CPU主动轮询I/O设备中与状态相关的寄存器，从而可以了解到I/O设备的工作状态。

设备驱动程序
----------------------------------------

上面只是介绍了CPU和I/O设备之间的交互手段。如果从操作系统角度来看，我们还需要对特定设备编写设备驱动程序。它一般需要完成如下一些功能：

1. 设备初始化，即完成对设备的初始配置
2. 如果设备会产生中断，需要有处理这个设备中断的中断处理例程（Interrupt Handler）
3. 根据操作系统上层模块（如文件系统）的要求（如读磁盘数据），给I/O设备发出命令
4. 与操作系统上层模块进行交互，完成上层模块的要求（如上传读出的磁盘数据）


编写设备驱动程序代码需要注意三方面的潜在风险：了解硬件规范，从而能够正确地与硬件交互，并能处理访问硬件出错的情况；由于设备驱动程序与它所管理的设备会同时执行，也可能与操作系统其他模块并行访问相关共享资源，所以需要考虑同步互斥的问题（后续会深入讲解操作系统同步互斥机制），并考虑到申请资源失败后的处理。理解驱动程序执行中所处的上下文：如果是在进行中断处理，那是在中断上下文中执行；如果是在代表进程的内核线程中执行，那是在内核线程上下文执行。这样才能写出正确的设备驱动程序。