I/O接口
=========================================

本节导读
-----------------------------------------


I/O设备概述
-----------------------------------------

I/O设备从早期相对比较简单的串口、键盘和磁盘等，逐步发展壮大，已经形成种类繁多，不同领域的各种类型的设备大家庭。而各种设备之间功能不一，性能差异巨大，难以统一地进行管理，这使得对应I/O设备的设备驱动程序成为了操作系统中最繁杂的部分。

站在不同的角度会对I/O设备有不同的理解。在硬件工程师看来，I/O设备就是一堆芯片、电源和其他电路的组合；而软件程序员则主要关注I/O设备为软件提供的接口（interface），即硬件能够接收的命令、能够完成的功能以及能产生的各种响应或错误等。操作系统重点关注的是如何对I/O设备进行管理，而不是其内部的硬件工作原理。然而，对许多I/O设备进行编程还是不可避免地涉及到其内部的硬件细节。如果对I/O设备的发展历史进行深入分析，是可以找到I/O设备的共性特点，属性分类，从而可以更好地通过操作系统来管理I/O设备。


I/O设备的发展历史
~~~~~~~~~~~~~~~~~~~~~~~~~~~

计算机的发展历史可体现为计算机硬件中各个部件的复杂度和集成度的变化发展过程。而在I/O设备变化过程相对比较显著，大致可分为如下阶段：

 1. CPU通过I/O接口（如嵌入式系统中的通用输入输出GPIO接口）直接控制I/O设备（如简单的发光二极管等），这在简单的单片机和微处理器控制设备中经常见到。其特点是CPU发出I/O命令或数据，可立刻驱动I/O设备并产生相应的效果。
   
 2. 在CPU与I/O设备之间增加了一层--I/O控制器（如串口控制器等）。处理器可对I/O控制器进行编程。其特点是CPU给I/O控制器发出I/O命令或读写数据，由I/O控制器来直接控制I/O设备和传达I/O设备的信息给CPU。CPU还需通过访问I/O控制器相关寄存器获取I/O设备的当前状态。其特点是CPU需要轮询检查设备情况，对于低速设备（如串口等）而言，高速CPU和低速设备之间是一种串行执行的过程，导致CPU利用率低。 随着设备的增多，I/O控制器也逐渐通用化（如各种总线接口等），把不同设备连接在一起，并能把设备间共性的部分进行集中管理。


 3. 为了解决CPU利用率低的问题，I/O控制器扩展了中断机制（（如Intel推出的8259可编程中断控制器）。CPU发出I/O命令后，无需轮询忙等，可以干其他事情。但外设完成I/O操作后，会通过I/O控制器尝产生外部中断，让CPU来响应这个外部中断。由于CPU无需一直等待外设执行I/O操作，这样就能让CPU和外设并行执行，提高整个系统的执行效率。


 4. 如果每次中断产生的I/O数据传输量少，那么I/O设备（如硬盘/SSD等）要在短期内传输大量数据就会频繁中断CPU，导致中断处理的总体开销很大。通过DMA（Direct Memory Access，直接内存访问）控制器（如Intel推出8237DMA控制器等），可以让外设在CPU没有访问内存的时间段中，以数据块的方式进行外设和内存之间的数据传输，且不需要CPU的干预。这样I/O设备的传输效率就大大提高了。CPU只需在开始传送前发出DMA指令，并在外设结束DMA操作后响应其发出的中断信息即可。
   
 在上述的I/O设备发展过程可以看到，I/O设备可以在没有CPU参与的情况下执行，使得CPU从I/O任务中解脱出来，从而提高了系统的整体性能。在后面的小节中，我们会进一步介绍基于I/O控制器的轮询，中断等方式的设备驱动的设计与实现。

 .. note::

    DMA技术工作流程：

    当CPU想与外设交换一块数据时，它会向DMA控制器发出一条命令。命令内容包括：读或写操作标记，相关的I/O设备的地址，内存的起始地址和长度。然后CPU继续其它工作。DMA控制器收到命令后，会直接从内存中或向内存传送整块数据，这个传输过程不再需要通过CPU进行操作。传送结束后，DMA控制器会通过I/O控制器给CPU发送一个表示DMA操作结束的中断。CPU在收到中断后，知道这次I/O操作完成，可进行后续相关事务的处理。

    在后续讲解的virtio-blk, virtio-gpu等模拟设备中，就是通过DMA来传输数据的。


I/O设备的分类
~~~~~~~~~~~~~~~~~~~~~~~~~~~

I/O设备种类繁多，但我们还是可以从数据传输的特点来给I/O设备进行分类。早期的UNIX把I/O设备分为两类：块设备（block device）和字符设备（character device）。块设备（比如磁盘）把信息存储在固定大小的块中，每个块有独立的地址。块的大小一般在0.5KB至32KB不等。块设备的I/O传输以一个或多个完整的（连续的）块为单位。另一类I/O设备是字符设备，字符设备（如串口，键盘等）以单个字符为单位发送或接收一个字符流。字符设备不需要寻址，只需访问I/O设备提供的相关接口即可获得/发出字符信息流。

后来随着网络的普及，又出现了一类设备：网络设备。网络面向报文而不是面向字符流，也不是面向数据块，还具有数据丢失等可靠性问题，因此将网络设备映射为常见的文件比较困难。为此UNIX的早期继承者BSD（Berkeley Software Distribution）提出了socket接口和对应操作，形成了事实上的TCP/IP网络API标准。

再后来随着个人电脑的普及，计算机已经进入寻常百姓家中，计算机的功能和控制范围进一步放大，各种类型的I/O设备层出不穷。GPU、声卡、显卡等外设已经很难归类到上述的三种分类中，所以它们也就形成了各自独立的设备类型。各种设备出现时间有早晚，功能特点各异，这也使得现有的操作系统在设备驱动的设计和实现上面比较繁杂。

CPU与I/O设备之间的交互
------------------------------------------

CPU控制与管理I/O设备的手段是通过对I/O控制器发命令或读写特定地址空间来完成的。其处理方式一般有两种，一种是通过特定的I/O指令，如x86中的 ``in`` 和 ``out ``指令，来访问I/O控制器；另外一种是通过内存读写方式，即MMIO(Memory mapping I/O)，把I/O控制器和各种外设的相关寄存器映射到一段特定的内存空间，通过读写这段特定的内存空间来访问I/O控制器。

第一种通过I/O指令访问的地址空间是I/O地址空间，这个访问内存用到的物理地址空间是两个不同的概念，例如，对于32位的Intel 80386处理器而言，其I/O地址空间为64K，而他的内存所在物理地址空间是4G。这两个空间是相互正交的。

I/O设备想主动通知CPU则主要是通过中断机制来完成的。比如通过设置时钟外设的相关时长寄存器，可以让时钟在规定的时间间隔到达时，产生一个中断，并通过I/O控制器与CPU之间的连接通知到CPU。这样CPU在执行完一条指令后，就能够发现中断的产生，并对外设进行相应的处理。当然，也I/O设备也可被动地“通知”CPU，即CPU主动轮询I/O设备中与状态相关的寄存器，从而可以了解到I/O设备的工作状态。

写设备驱动程序的基本思路
----------------------------------------

从操作系统架构上看，设备驱动程序与I/O设备靠的更近，离应用程序更远，这使得设备驱动程序需要站在协助所有进程的全局角度来处理各种I/O操作。这也就意味着在设备驱动程序的设计实现中，尽量不要与单个进程建立直接的联系，而是在全局角度对I/O设备进行统一处理。

上面只是介绍了CPU和I/O设备之间的交互手段。如果从操作系统角度来看，我们还需要对特定设备编写设备驱动程序。它一般需要完成如下一些功能：

1. 设备初始化，即完成对设备的初始配置
2. 如果设备会产生中断，需要有处理这个设备中断的中断处理例程（Interrupt Handler）
3. 根据操作系统上层模块（如文件系统）的要求（如读磁盘数据），给I/O设备发出命令
4. 与操作系统上层模块进行交互，完成上层模块的要求（如上传读出的磁盘数据）

从驱动程序I/O操作的执行模式上看，主要有两种模式的I/O操作：异步和同步。同步模式下的处理逻辑类似函数调用，从应用程序发出I/O请求，通过同步的系统调用传递到操作系统内核中，操作系统内核的各个层级进行相应处理，并最终把相关的I/O操作命令转给了驱动程序。一般情况下，驱动程序完成相应的I/O操作会比较慢（相对于CPU而言），所以操作系统会让代表应用程序的进程进入等待状态，进行进程切换。但相应的I/O操作执行完毕后（操作系统通过轮询或中断方式感知），操作系统会在合适的时机唤醒等待的进程，从而进程能够继续执行。

异步I/O操作是一个效率更高的执行模式，即应用程序发出I/O请求后，并不会等待此I/O操作完成，而是继续处理应用程序的其它任务（这个任务切换会通过运行时库或操作系统来完成）。调用异步I/O操作的应用程序需要通过某种方式（比如某种异步通知机制）来确定I/O操作何时完成。这部分可以通过协程技术来实现，但目前我们不会就此展开讨论。

编写设备驱动程序代码需要注意三方面的潜在风险：了解硬件规范，从而能够正确地与硬件交互，并能处理访问硬件出错的情况；由于设备驱动程序与它所管理的设备会同时执行，也可能与操作系统其他模块并行访问相关共享资源，所以需要考虑同步互斥的问题（后续会深入讲解操作系统同步互斥机制），并考虑到申请资源失败后的处理。理解驱动程序执行中所在的可能的上下文环境：如果是在进行中断处理（如在执行 ``trap_handler`` 函数），那是在中断上下文中执行；如果是在代表进程的内核线程中执行后续的I/O操作（如收发TCP包），那是在内核线程上下文执行。这样才能写出正确的设备驱动程序。
