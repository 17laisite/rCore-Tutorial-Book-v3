引言
=========================================

本章导读
-----------------------------------------

到本章开始之前，我们好像已经完成了组成应用程序执行环境的操作系统的三个重要抽象：进程、地址空间和文件，让应用程序开发、运行和存储数据越来越方便和灵活。特别是操作系统支持分时多任务和抢占式调度，通过硬件中断机制，能强制打断进程的执行，及时处理I/O交互操作，从而提高整个系统的执行效率。有了进程以后，可以让操作系统从宏观层面实现多个应用的并发执行，而并发是通过操作系统基于处理器的时间片不断地切换进程来达到的。对于单核处理器而言，在任意一个时刻只会有一个进程被操作系统调度，在被处理器上执行。到目前为止的并发，仅仅是进程间的并发，而对于一个进程内部，还没有并发性的体现。而这就是线程（Thread）出现的起因：提高一个进程内的并发性。

.. note::

	**并行与并发的区别**

	可回顾一下 :ref:`并行与并发的解释 <term-parallel-concurrency>` 。


有了进程以后，为什么还会出现线程（Thread）呢？考虑如下情况，对于很多应用（以单一进程的形式运行）而言，逻辑上存在多个可并行执行的任务，如果其中一个任务被阻塞，将会引起不依赖该任务的其他任务也被阻塞。举个具体的例子，我们平常用编辑器来编辑文本内容的时候，都会有一个定时自动保存的功能，这个功能的作用是在系统或应用本身出现故障的情况前，已有的文档内容会被提前保存。假设编辑器自动保存时由于磁盘性能导致写入较慢，导致整个进程被操作系统挂起，这就会影响到用户编辑文档的人机交互体验：即软件的及时响应能力不足，用户只有等到磁盘写入完成后，操作系统重新调度该进程运行后，用户才可编辑。如果我们把一个进程内的多个可并行执行任务通过一种更细粒度的方式让操作系统进行调度，那么就可以通过处理器时间片切换实现这种细粒度的并发执行。这种细粒度的调度对象就是线程。

线程定义
~~~~~~~~~~~~~~~~~~~~

简单地说，线程是进程的组成部分，进程可包含1 -- n个线程，属于同一个进程的线程共享进程的资源，比如地址空间，打开的文件等。基本的线程由线程ID，当前指令指针(PC)，寄存器集合和栈组成。线程是可以被操作系统或用户态调度器独立调度（Scheduling）和分派（Dispatch）的基本单位。

在本章之前，进程是程序的基本执行实体，是程序关于某数据集合上的一次运行活动，是系统进行资源（处理器，地址空间和文件等）分配和调度的基本单位。在有了线程后，对进程的定义也要调整了，进程是线程的资源容器，线程成为了程序的基本执行实体。


.. note::

	**线程与进程的区别**

	下面的比较是以线程为调度对象的操作系统作为分析对象：

	* 进程间相互独立（即资源隔离），同一进程的各线程间共享进程的资源（即资源共享）；
	* 子进程和父进程有不同的地址空间和资源，而多个线程（没有父子关系）则共享同一所属进程的地址空间和资源；
	* 每个线程有其自己的执行上下文（线程ID、程序计数器、寄存器集合和执行栈），而进程的执行上下文包括其管理的线程执行上下文和地址空间（故同一进程的线程上下文切换比进程上下文切换要快）；
	* 线程是一个可调度/分派/执行的实体（线程有就绪、阻塞和运行三种基本执行状态），进程不是可调度/分派/执行的的实体，而是线程的资源容器；
    * 进程间通信需要通过IPC机制（如管道等）， 属于同一进程的线程间可以共享“即直接读写”进程的数据，但需要同步互斥机制的辅助，以保证数据的一致性。


同步互斥
~~~~~~~~~~~~~~~~~~~~~~

在上面提到了同步互斥和数据一致性，它们的含义是什么呢？ 当多个线程共享同一进程的地址空间时，每个线程都可以访问属于这个进程的数据（全局变量）。如果每个线程使用到的变量都是其他线程不会读取或者修改的话，那么就不存在一致性问题。如果变量是只读的，多个线程读取该变量也不会有一致性问题。但是，当一个线程修改变量时，其他线程在读取这个变量时，可能会看到一个不一致的值，这就是数据不一致性的问题。


.. note::

	**线程的数据一致性**

	线程的数据一致性的定义：在单处理器（即只有一个核的CPU）下，如果某线程更新了一个可被其他线程读到的数据，那么其他线程都能读到这个最新的更新数据。

为什么会出现线程的数据不一致问题呢？

为了保证线程的数据一致性，需要通过操作系统提供的互斥机制来帮助线程执行之间的协调。


.. chyyuu 例子？？？