实现 SV39 多级页表机制
========================================================

在本章第一小节中我们简单介绍了分页的内存管理策略，本节我们在 RV64 架构提供的 SV39 分页机制的基础上完成内核中的
软件对应实现。

SV39 的虚拟地址和物理地址
------------------------------------------------------

默认情况下 MMU 未被使能，此时无论 CPU 位于哪个特权级，访存的地址都会作为一个物理地址交给对应的内存控制单元来直接
访问物理内存。我们可以通过修改 S 特权级的一个名为 ``satp`` 的 CSR 来启用分页模式，在这之后 S 和 U 特权级的访存
地址会被视为一个虚拟地址，它需要经过 MMU 的地址转换变为一个物理地址，再通过它来访问物理内存；而 M 特权级的访存地址
被视为一个物理地址还是一个需要经历和 S/U 特权级相同的地址转换的虚拟地址则取决于配置，在这里我们并不深入。

.. image:: satp.png

上图是 RV64 架构下 ``satp`` 的字段分布。当 ``MODE`` 设置为 0 的时候，代表所有访存都被视为物理地址；而设置为 8 
的时候，SV39 分页机制被启用，所有 S/U 特权级的访存被视为一个 39 位的虚拟地址，它们需要先经过 MMU 的地址转换流程，
如果顺利的话，则会变成一个 56 位的物理地址来访问物理内存；否则则会触发异常，这体现了该机制的内存保护能力。

.. image:: sv39-va-pa.png

虚拟地址和物理地址都是字节地址， 39 位的虚拟地址可以用来访问大小为 :math:`512\text{GiB}` 的地址空间，
而 56 位的物理地址