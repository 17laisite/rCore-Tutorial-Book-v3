超越物理内存的地址空间
==============================================================


本节导读
--------------------------

有限的物理内存
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


到目前为止，在面向批处理系统的操作系统中，正在运行的任务只有一个，可以访问计算机的整个物理内存空间。如果物理内存空间不够，任务需要比较小心翼翼的地申请和释放内存，来确保在当前时间段中内存够用。在面向多道程序的协作式操作系统或面向分时多任务的抢占式操作系统中，由于在内存中会有多个任务来共享整个物理内存，且任务之间的物理内存空间是隔离的，导致任务越多，每个任务可用的物理内存空间会越少。这样，在提高CPU利用率和任务间的隔离安全性的同时，一个比较严重的问题出现了： **物理内存不够用** 。

.. note::

	为什么要为应用程序支持巨大的地址空间？

	在计算机发展的早期，计算机系统上的应用程序一般不需要巨大的地址空间，更需要的是强劲的CPU处理能力。但从二十世纪七十年代末开始的个人计算机一路发展至今，存在着某种动力使得人们如此频繁地更新计算机设备，这就是：

	**安迪比尔定律：比尔要拿走安迪所给的（What Andy gives, Bill takes away）**

	Intel处理器的速度每十八个月翻一番，计算机内存和硬盘的容量以更快的速度在增长。过去的MS DOS操作系统和DOS应用程序在内存容量为640KB的计算机上顺畅地运行。而现在的Windows 11和Windows应用程序在内存容量8GB的计算机上仅勉强够用，而建议的内存配置是16GB（是640KB的25600倍）。虽然新的软件功能比以前的版本强了一些，但其增加的功能和它的大小不成比例。

	那大内存带来的好处是啥？ **方便！** 一般用户可以在计算机上同时开启多个应用：文字编辑、上网浏览、视频会议等，享受方便的数字生活。应用程序开发者不必担心要处理的数据是否有足够空间存储，只需编写程序，根据数据所需空间分配内存即可，甚至都不需要考虑释放内存的操作。

	注：安迪是Intel公司 CEO 安迪·格鲁夫（Andy Grove），比尔是微软公司创始人比尔·盖茨（Bill Gates）。


超越物理内存的方法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

我们需要突破物理内存有限的限制，这需要通过应用程序的软件编程技巧或操作系统与硬件结合的内存管理机制来解决。首先，我们可以看看基于应用程序本身的方法，即分时复用内存：即应用程序/运行时库动态地申请和释放内存，让不同的数据在不同时间段内共享同一块内存空间。

另外一种方法是基于操作系统的方法，即把远大于且远慢于物理内存的存储设备（如硬盘、SSD等）利用起来作为内存的一部分。如果把正在运行的任务所没用到的物理内存空间，比如处于等待状态的任务所使用的物理内存空间，甚至是正在运行的任务会较晚访问的数据所占用的内存空间，移出并暂存在存储设备中，那么应用程序可以访问的内存空间（虚拟的）就包括了存储设备的巨大容量了。

当然还有其他一些针对特定使用场景下的不太常用的方法，比如内存压缩方法。对于需要处理大数据的应用而言，内存中存放的主要是各种数据，而很多数据（如具有大量重复的值）是可以被压缩的。所以采用一定的压缩数据的结构和数据压缩方法，可以有效地减少数据占用的内存空间。

这些给应用程序带来好处的方法，也会引入各种运行时的开销，如果处理不当，会让任务本身，甚至整个系统的执行效率大大下降。所以，我们希望通过设计有效的机制和策略，能在扩大虚拟的内存容量的同时，保证应用程序和系统能够高效地运行。


分时复用内存
--------------------------------

考虑到应用程序在其运行中的不同时间段内，会使用不同的数据，所以可以让这些数据在不同的时间段内共享同一内存空间。这就是分时复用内存的基本思路。当应用程序从操作系统中只能获得一块固定大小的有限内存空间（称为：空闲空间）后，应用程序一般会采用动态分配内存的方式来合理使用有限的物理内存。在本章的 :ref:`Rust 中的动态内存分配 <term-dynamic-allocation>` 一节中，讲述了动态内存分配的基本概念。如何动态地管理空闲内存以提高内存的使用效率，是一个需要进一步讨论的问题。我们将讲述两种方法：

- 动态内存分配：由应用程序主动发出申请或释放内存的动态请求，由运行时库或应用程序本身通过一定的策略来管理空闲空间。
- 覆盖技术：一个应用程序中存在若干个功能上相对独立的程序段（函数集合），它们不会同时执行，所以它们可以共享同一块内存空间。这需要应用程序开发者根据需要手动移入或移出内存中的代码或数据。


动态内存分配
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

动态分配内存的目标是处理快速和浪费的空闲空间碎片少。这里我们会进一步分析动态分配内存的策略。对于不同的分配需求的前提情况，会有不同的分配策略。比如，每次分配的空间大小是固定的，那么就可以把空闲空间按固定大小的单元组织为一个列表。当需要分配时，从列表中的第一个单元取出即可；但需要回收时，把回收单元放到列表的末尾即可。

但应用程序需要的内存空间一般时大小不一的，这就需要相对复杂一些的策略来管理不同大小的空闲单元了。

最先匹配（first fit）策略
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

首次匹配策略的思路很简单：尽快找到满足用户需求的空闲块。大致处理流程就是把空闲空间基于地址顺序组织为大小不一的空闲块列表。当需求方需要大小为n的空闲块时，搜索空闲块列表，找到第一个足够大的空闲块；如果此空闲块大小刚好为n，则把此空闲块返回给需求方；如果此空闲块大小大于n，则把空闲块分割为大小为n的前面部分和剩余部分，大小为n的前面部分返回给需求方，而剩余部分会回归给空闲块列表管理，留给后续请求。

最先匹配策略不需要遍历空闲列表查找所有空闲块，所以有速度上的优势，但释放的时间有一定的随机性，这可能会让空闲列表开头的部分有很多小块。

最优匹配（best fit）策略
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

最优匹配（best fit）策略的思路也很简单：选择最接近需求方请求大小的块，从而尽量避免空间浪费。也是把空闲空间基于地址顺序组织为大小不一的空闲块列表。当需求方需要大小为n的空闲块时，遍历整个空闲列表，找到足够大且二者空间大小差距最小的空闲块。其代价是时间，即需要遍历一次空闲列表，找到最合适的空闲块。而且还有可能造成空间的浪费，因为可能产生很多小的空闲碎片，虽然碎片容量的总和比较大，当无法满足内存分配请求。

最差匹配（worst fit）策略
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

最差匹配（worst fit）策略的思路与最优匹配策略相反，它尝试找最大的空闲块，这也需要遍历一次空闲列表。当对找到的空闲块进行分割并满足用户需求后，剩余的空闲部分相对于最优匹配或最先匹配策略剩余的空闲部分相比，在大小上要大不少，可能被再次分配出去的概率要大。但最差匹配策略同样需要遍历整个空闲列表，带来较大的性能开销；且在应用频繁申请和释放的随机情况下，也可能会产生大量的碎片。


减少碎片
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

其实，采用上面的三种策略，都会由于对空闲块进行分割而产生碎片。所以减少碎片是一个需要考虑的重要问题。减少碎片有两种方法，第一种方法是合并操作，即在内存释放操作中，把在地址连续的多个空闲块合并为一个大的空闲块，这样可以满足更多的内存分配请求。

第二种方法是比较激进的紧致（compaction，也称紧凑）操作，即把地址不连续的多个空闲块移动在一个连续的地址空间中，形成一个大的空闲块。在移动空闲块的过程中，也需要移动已经分配的内存块。这除了带来性能上的影响外，还会带来数据寻址问题，应即用程序中数据所在的内存地址会发生改变，应用程序要能够感知这种变化，才能正确访问更新后的数据地址。这需要应用程序具有在紧致操作后的数据地址更新功能，这对应用程序开发者提出了很高的要求，不具有通用性。

覆盖（Overlay）技术
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

覆盖技术是指一个应用程序在执行过程中，其若干程序段分时共享同一块内存空间。覆盖技术的大致思路是编写一个应用程序，把它分为若干个功能上相对独立的程序段（函数集合），按照其逻辑执行结构，这些程序段不会同时执行。未执行的程序段先保存在存储设备上，当有关程序段的前一部分执行结束后，把后续程序段和数据调入内存，覆盖前面的程序段和数据。

覆盖技术需要程序员在编写应用程序时，来手动控制和管理何时进行覆盖，不同程序段的覆盖顺序，以及覆盖的具体空间位置。这虽然减少了应用程序在执行过程中对内存空间的需求，当对应用程序开发者的编程水平提出了很高的要求，而且通用性比较差。

页面替换机制
--------------------------------

页表存在位
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

作为交换区的存储设备
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

内存访问异常处理
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


页面替换策略
--------------------------------

局部性原理
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

评价指标
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

算法分类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

局部页面置换算法

全局页面置换算法



最优置换策略
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FIFO置换策略
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

LRU置换策略
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Clock置换策略
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

工作集置换策略
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

缺页率置换策略
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Belady现象
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


小结
--------------------------------