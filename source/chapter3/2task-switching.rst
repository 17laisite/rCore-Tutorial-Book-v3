任务切换
================================

本节我们来介绍本章的核心机制——任务切换。在上一章批处理系统中，一个应用会独占 CPU 直到它出错或主动退出。而本章中，一个应用在运行途中便会
主动/被动交出 CPU 的使用权，此时它只能暂停执行，等到内核重新给它分配 CPU 资源之后才能恢复并继续执行。

我们又看到了熟悉的“暂停-继续”组合。一旦一条执行流需要支持“暂停-继续”，就需要提供一种执行流切换的机制，而且需要保证执行流被切换出去之前和
切换回来之后，它的状态，也就是在执行过程中同步变化的资源（如寄存器、栈等）需要保持不变，或者变化在它的预期之内。而不是所有的资源都需要被
保存，事实上只有那些对于执行流接下来的进行仍然有用，且在它被切换出去的时候有被覆盖的风险的那些资源才有被保存的价值。这些资源被称为上下文。

在执行流切换过程中，我们需要结合硬件机制和软件实现来保存和恢复上下文。一次执行流的切换涉及到被换出和即将被换入的两条执行流，通常它们都需要
共同遵循某些约定来合作完成这一过程。在前两章，我们已经看到了两种上下文保存/恢复的实例。让我们再来回顾一下它们：

- 第一章《RV64 裸机应用》中，我们介绍了 :ref:`函数调用与栈 <function-call-and-stack>` 。当时提到过，为了支持嵌套函数调用，不仅需要
  硬件平台提供特殊的跳转指令，还需要保存和恢复 **函数调用上下文** 。注意在 *我们* 的定义中，函数调用包含在普通控制流（与异常控制流相对）之内
  ，且始终用一个固定的栈来保存执行的历史记录，因此函数调用并不涉及执行流的切换。但是我们依然可以将其看成调用者和被调用者两个过程的“切换”，
  二者的协作体现在它们都遵循调用规范，分别保存一部分通用寄存器，这样的好处是编译器能够有足够的信息来尽可能减少需要保存的寄存器的数目。
  虽然当时用了很大的篇幅来说明，但其实整个过程都是编译器负责完成的，我们只需设置好栈就行了。
- 第二章《批处理系统》中第一次涉及到了某种异常控制流，即两条控制流的切换。当时，为了让内核能够 *完全掌控* 应用的执行，我们必须利用硬件
  提供的特权级机制，让应用和内核运行在不同的特权级。应用运行在 U 特权级，它所被允许的操作进一步受限，处处被内核监督管理；而内核运行在 S 
  特权级，有能力处理应用执行过程中提出的请求或遇到的状况。
  
  二者打交道的核心在于硬件提供的 Trap 机制，也就是在 U 特权级运行的应用执行流和在 S 特权级运行的 Trap 执行流之间的切换。
  Trap 执行流是在 Trap 触发的一瞬间生成的，它和原应用执行流有着很密切的联系，因为它唯一的目标就是处理 Trap 并恢复到原应用执行流。而且，
  由于 Trap 机制对于应用来说几乎是透明的，所以基本上都是 Trap 执行流在“负重前行”。Trap 执行流需要把 **Trap 上下文** 保存在自己的
  内核栈上，里面包含几乎所有的通用寄存器，因为在 Trap 处理过程中它们都可能被用到。如果有需要的话，可以回看 
  :ref:`Trap 上下文保存与恢复 <trap-context-save-restore>` 小节。

本节的任务切换是第二章的 Trap 之后的另一种异常控制流，都描述两条执行流之间的切换，如果将它和 Trap 进行比较：

- 与 Trap 不同，它不涉及特权级切换；
- 与 Trap 不同，它的一部分是由编译器帮忙完成的；
- 与 Trap 相同，它对应用是透明的。

事实上，它是来自两个不同应用的 Trap 执行流之间的切换。当一个应用 Trap 到 S 进行处理的时候，其 Trap 
执行流 **主动** 调用一个 ``__switch`` 函数来切换到另一个应用的 Trap 执行流。这个 ``__switch`` 有两个参数，分别指明被换出和即将被换入的
两个 Trap 执行流，参数的详细含义将在后面说明。一个被换出的执行流稍后也可以被重新换入并继续执行，这只需要将它的“指示器”作为第二个参数传给 
``__switch`` ，而不是像它被换出的时候作为第一个参数即可。如果将视角固定在一个 Trap 执行流， ``__switch`` 可以看成一次普通的函数调用，
只不过在调用期间该执行流经历了一次完整的换出换入过程。

.. code-block:: riscv
    :linenos:

    .altmacro
    .macro SAVE_SN n
        sd s\n, (\n+1)*8(sp)
    .endm
    .macro LOAD_SN n
        ld s\n, (\n+1)*8(sp)
    .endm
        .section .text
        .globl __switch
    __switch:
        # __switch(current_task_cx: &*const TaskContext, next_task_cx: &*const TaskContext)
        # push TaskContext to current sp and save its address to where a0 points to
        addi sp, sp, -13*8
        sd sp, 0(a0)
        # fill TaskContext with ra & s0-s11
        sd ra, 0(sp)
        .set n, 0
        .rept 12
            SAVE_SN %n
            .set n, n + 1
        .endr
        # ready for loading TaskContext a1 points to
        ld sp, 0(a1)
        # load registers in the TaskContext
        ld ra, 0(sp)
        .set n, 0
        .rept 12
            LOAD_SN %n
            .set n, n + 1
        .endr
        # pop TaskContext
        addi sp, sp, 13*8
        ret