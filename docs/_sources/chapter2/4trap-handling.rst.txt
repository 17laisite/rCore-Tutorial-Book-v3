处理 Trap
=======================

.. toctree::
   :hidden:
   :maxdepth: 5

我们知道，批处理系统被设计为运行在 S 模式，这是由作为它运行环境的 SEE 所保证的；而应用程序被设计为运行在 U 模式，这个则是我们的批处理系统
所保证的。批处理系统作为应用程序的执行环境，需要在执行应用程序之前进行一些初始化工作，并监控应用程序的执行，具体体现在：

- 当应用程序发起系统调用之后，需要到批处理系统中进行处理；
- 当应用程序执行出错的时候，需要到批处理系统中杀死该应用并加载运行下一个应用； 
- 当应用程序执行结束的时候，需要到批处理系统中加载运行下一个应用（实际上也是通过系统调用 ``sys_exit`` 来实现的）。

这些处理都涉及到特权级切换，因此都需要硬件提供的 Trap 机制。当从一般意义上讨论 RISC-V 架构的 Trap 机制时，通常需要注意两点：在
触发 Trap 之前 CPU 运行在哪个特权级；以及 CPU 需要切换到哪个特权级来处理该 Trap 并在处理完成之后返回原特权级。但本章中我们仅考虑
当 CPU 在 U 特权级运行用户程序的时候触发 Trap，并切换到 S 特权级的批处理系统的对应服务代码来进行处理。

在 RISC-V 架构中，关于 Trap 有一条重要的规则：在 Trap 前后特权级不会下降。因此如果触发 Trap 之后切换到 S 特权级（下称 Trap 到 S），
说明 Trap 发生之前 CPU 只能运行在 S/U 特权级。但无论如何，只要是 Trap 到 S，硬件就会使用 S 特权级与 Trap 相关的 CSR 来辅助 Trap 
处理。我们在编写运行在 S 特权级的批处理系统中的 Trap 处理相关代码的时候，也需要使用它们。

.. list-table:: 进入 S 特权级 Trap 的相关 CSR
   :header-rows: 1
   :align: center
   :widths: 30 100

   * - CSR 名
     - 该 CSR 与 Trap 相关的功能
   * - sstatus
     - ``SPP`` 字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）
   * - sepc
     - 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址
   * - scause
     - 描述 Trap 的原因
   * - stval
     - 给出 Trap 附加信息
   * - stvec
     - 控制 Trap 处理代码的入口地址

.. note::

   **多功能的 sstatus**

   注意 ``sstatus`` 是 S 特权级最重要的 CSR，可以从很多方面控制 S 特权级的行为并描述其状态。我们在这里先给出它对 Trap 处理的作用。

大多数的 Trap 发生的场景都是在执行某条指令之后，CPU 发现触发了一个 Trap 并需要进行处理。异常是 Trap 的一种，它与某条指令的执行有关，
但这条触发 Trap 的指令和进入 Trap 之前执行的最后一条指令不一定是同一条。如果这个异常并非不可恢复的错误，比如只是通过 ``ecall`` 指令
向底层执行环境请求某项功能，那么上层软件期待底层环境处理完成后，还能够从上层软件被打断的位置继续执行，参考 :ref:`图示 <environment-call-flow>` 。

.. _term-execution-of-thread:

回顾第一章的 :ref:`函数调用与栈 <function-call-and-stack>` ，我们知道在一个固定的 CPU 上，只要有一个栈作为存储空间，我们就能以多种
普通控制流（顺序、分支、循环结构和多层嵌套函数调用）组合的方式，来一行一行的执行源代码（以编程语言级的视角），也是一条一条的执行汇编指令
（以汇编语言级的视角）。只考虑普通控制流，那么从某条指令开始记录，该 CPU 可用的所有资源，包括自带的所有通用寄存器（包括虚拟的描述当前执行
指令地址的寄存器 pc ）和当前特权级可用的 CSR 以及位于内存中的一块栈空间，它们会随着指令的执行而逐渐发生变化。这种局限在普通控制流之内的
连续指令执行和与之同步的对相关资源的改变我们用一个新名词 **执行流** (Execution of thread) 来命名。由此衍生出来的概念，执行流的状态
则指的是对于某条执行流而言，截止到某条指令执行完毕，所有相关资源（包括寄存器、栈）的状态集合，它完整描述了自记录起始之后该执行流的指令
执行历史。

.. note::

   实际上 CPU 还有其他资源可用：

   - 内存除了与执行流绑定的栈之外的其他存储空间，比如程序中的数据段；
   - 外围 I/O 设备。

   它们也会在执行期间动态发生变化。但它们可能由多条执行流共享，难以清晰的从中单独区分出某一条执行流的状态变化。因此在执行流概念中，
   我们不将其纳入考虑。

仔细考虑 Trap ，我们可以将其理解为借助异常控制流完成的两个执行流之间的切换！

.. 
   马老师发生甚么事了？
   --
   这里要说明目前只考虑从 U Trap 到 S ，而实际上 Trap 的要素就有：Trap 之前在哪个特权级，Trap 在哪个特权级处理。这个对于中断和异常
   都是如此，只不过中断可能跟特权级的关系稍微更紧密一点。毕竟中断的类型都是跟特权级挂钩的。但是对于 Trap 而言有一点是共同的，也就是触发 
   Trap 不会导致优先级下降。从中断/异常的代理就可以看出从定义上就不允许代理到更低的优先级。而且代理只能逐级代理，目前我们能操作的只有从 
   M 代理到 S，其他代理都基本只出现在指令集拓展或者硬件还不支持。中断的情况是，如果是属于某个特权级的中断，不能在更低的优先级处理。事实上
   这个中断只可能在 CPU 处于不会更高的优先级上收到（否则会被屏蔽），而 Trap 之后优先级不会下降（Trap 代理机制决定），这样就自洽了。
   --
   之前提到异常是说需要执行环境功能的原因与某条指令的执行有关。而 Trap 的定义更加广泛一些，就是在执行某条指令之后发现需要执行环境的功能，
   如果是中断的话 Trap 回来之后默认直接执行下一条指令，如果是异常的话硬件会将 sepc 设置为 Trap 发生之前最后执行的那条指令，而异常发生
   的原因不一定和这条指令的执行有关。应该指出的是，在大多数情况下都是和最后这条指令的执行有关。但在缓存的作用下也会出现那种特别极端的情况。
   --
   然后是 Trap 到 S，就有 S 模式的一些相关 CSR，以及从 U Trap 到 S，硬件会做哪些事情（包括触发异常的一瞬间，以及处理完成调用 sret 
   之后）。然后指出从用户的视角来看，如果是 ecall 的话， Trap 回来之后应该从 ecall 的下一条指令开始执行，且执行现场不能发生变化。
   所以就需要将应用执行环境保存在内核栈上（还需要换栈！）。栈存在的原因可能是 Trap handler 是一条新的运行在 S 特权级的执行流，所以
   这个可以理解成跨特权级的执行流切换，确实就复杂一点，要保存的内容也相对多一点。而下一章多任务的任务切换是全程发生在 S 特权级的执行流
   切换，所以会简单一点，保存的通用寄存器大概率更少（少在调用者保存寄存器），从各种意义上都很像函数调用。从不同特权级的角度来解释换栈
   是出于安全性，应用不应该看到 Trap 执行流的栈，这样做完之后，虽然理论上可以访问，但应用不知道内核栈的位置应该也有点麻烦。
   --
   然后是 rust_trap 的处理，尤其是奇妙的参数传递，内部处理逻辑倒是非常简单。
   --
   最后是如何利用 __restore 初始化应用的执行环境，包括如何设置入口点、用户栈以及保证在 U 特权级执行。





