

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>简易文件系统 easy-fs &mdash; rCore-Tutorial-Book-v3 0.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script kind="utterances">

    var commentsRunWhenDOMLoaded = cb => {
    if (document.readyState != 'loading') {
        cb()
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', cb)
    } else {
        document.attachEvent('onreadystatechange', function() {
        if (document.readyState == 'complete') cb()
        })
    }
}

var addUtterances = () => {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://utteranc.es/client.js";
    script.async = "async";

    script.setAttribute("repo", "rcore-os/rCore-Tutorial-Book-v3");
    script.setAttribute("issue-term", "pathname");
    script.setAttribute("theme", "github-light");
    script.setAttribute("label", "comments");
    script.setAttribute("crossorigin", "anonymous");

    sections = document.querySelectorAll("div.section");
    if (sections !== null) {
        section = sections[sections.length-1];
        section.appendChild(script);
    }
}
commentsRunWhenDOMLoaded(addUtterances);
</script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="在内核中使用 easy-fs" href="3using-easy-fs-in-kernel.html" />
    <link rel="prev" title="文件系统接口" href="1fs-interface.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> rCore-Tutorial-Book-v3
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Part1 - Just do it!</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../chapter0/index.html">第零章：操作系统概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter1/index.html">第一章：RV64 裸机应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter2/index.html">第二章：批处理系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter3/index.html">第三章：多道程序与分时多任务</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter4/index.html">第四章：地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter5/index.html">第五章：进程及重要系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter6/index.html">第六章：文件描述符与进程间通信</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第七章：数据持久化存储(施工)</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="0intro.html">引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="1fs-interface.html">文件系统接口</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">简易文件系统 easy-fs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">本节导读</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">块设备接口层</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">块缓存层</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">块缓存</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">块缓存全局管理器</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id6">磁盘布局及磁盘上数据结构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id7">easy-fs 磁盘布局概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">easy-fs 超级块</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">位图</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">磁盘上索引节点</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">数据块与目录项</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id12">磁盘块管理器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">索引节点</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">测试 easy-fs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">将应用打包为 easy-fs 镜像</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="3using-easy-fs-in-kernel.html">在内核中使用 easy-fs</a></li>
<li class="toctree-l2"><a class="reference internal" href="4cmdargs-and-redirection.html">命令行参数与标准 I/O 重定向</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Part2 - Do it better!</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../chapter8/index.html">第八章：阻塞（暂定）</a></li>
</ul>
<p class="caption"><span class="caption-text">附录</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix-a/index.html">附录 A：Rust 系统编程入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-b/index.html">附录 B：常见工具的使用方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-c/index.html">附录 C：深入机器模式：RustSBI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-d/index.html">附录 D：RISC-V相关信息</a></li>
<li class="toctree-l1"><a class="reference internal" href="../terminology.html">术语中英文对照表</a></li>
</ul>
<p class="caption"><span class="caption-text">开发注记</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../setup-sphinx.html">修改和构建本项目</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rest-example.html">reStructuredText 基本语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../log.html">更新日志</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">rCore-Tutorial-Book-v3</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">第七章：数据持久化存储(施工)</a> &raquo;</li>
        
      <li>简易文件系统 easy-fs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/chapter7/2fs-implementation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="easy-fs">
<h1>简易文件系统 easy-fs<a class="headerlink" href="#easy-fs" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>本节导读<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>本节我们介绍一个简易文件系统实现 easy-fs。作为一个文件系统而言，它的磁盘布局（为了叙述方便，我们用磁盘来指代一系列持久存储设备）体现在磁盘上各扇区的内容上，而它解析磁盘布局得到的逻辑目录树结构则是通过内存上的数据结构来访问的，这意味着它要同时涉及到对磁盘和对内存的访问。它们的访问方式是不同的，对于内存直接通过一条指令即可直接读写内存相应的位置，而磁盘的话需要用软件的方式向磁盘发出请求来间接进行读写。此外，我们也要特别注意哪些数据结构是存储在磁盘上，哪些数据结构是存储在内存中的，这样在实现的时候才不会引起混乱。</p>
<p>easy-fs 被从内核中分离出来，它的实现分成两个不同的 crate ：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 为简易文件系统的本体，它是一个库形式 crate，实现一种我们设计的简单磁盘布局；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">easy-fs-fuse</span></code> 是一个能在开发环境（如 Ubuntu）中运行的应用程序，它可以对 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 进行测试，或者将为我们内核开发的应用打包为一个 easy-fs 格式的文件系统镜像。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> crate 自下而上大致可以分成五个不同的层次：</p>
<ol class="arabic simple">
<li><p>块设备接口层</p></li>
<li><p>块缓存层</p></li>
<li><p>磁盘数据结构层</p></li>
<li><p>磁盘块管理器层</p></li>
<li><p>索引节点层</p></li>
</ol>
</div>
<div class="section" id="id2">
<h2>块设备接口层<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>在 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 库的最底层声明了一个块设备的抽象接口 <code class="docutils literal notranslate"><span class="pre">BlockDevice</span></code> ：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_dev.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">BlockDevice</span><span class="w"> </span>: <span class="nb">Send</span> <span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Any</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">read_block</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">write_block</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>它需要实现两个抽象方法：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">read_block</span></code> 可以将编号为 <code class="docutils literal notranslate"><span class="pre">block_id</span></code> 的块从磁盘读入内存中的缓冲区 <code class="docutils literal notranslate"><span class="pre">buf</span></code> ；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">write_block</span></code> 可以内存中的缓冲区 <code class="docutils literal notranslate"><span class="pre">buf</span></code> 中的数据写入磁盘编号为 <code class="docutils literal notranslate"><span class="pre">block_id</span></code> 的块。</p></li>
</ul>
<p>这是因为，之前提到过，块设备仅支持以块为单位进行随机读写，由此才有了这两个抽象方法。在 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 中并没有一个实现了 <code class="docutils literal notranslate"><span class="pre">BlockDevice</span></code> Trait 的具体类型，实际上这是需要由库的使用者提供并接入到 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 库的。这也体现了 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 的泛用性：它可以用于管理任何实现了 <code class="docutils literal notranslate"><span class="pre">BlockDevice</span></code> Trait 的块设备。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><strong>块与扇区</strong></p>
<p>实际上，块和扇区是两个不同的概念。 <strong>扇区</strong> (Sector) 是块设备随机读写的大小单位，通常每个扇区为 512 字节。而块是文件系统存储文件时的大小单位，每个块的大小等同于一个或多个扇区。之前提到过 Linux 默认文件系统的单个块大小为 4096 字节。在我们的 easy-fs 实现中一个块的大小和扇区相同为 512 字节，因此在后面的讲解中我们不再区分扇区和块的概念。</p>
</div>
</div>
<div class="section" id="id3">
<h2>块缓存层<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>由于 CPU 不能直接读写磁盘块，因此常见的手段是先通过 <code class="docutils literal notranslate"><span class="pre">read_block</span></code> 将一个块上的数据从磁盘读到内存中的一个缓冲区中，这个缓冲区中的内容是可以直接读写的。如果对于缓冲区中的内容进行了修改，那么后续需要通过 <code class="docutils literal notranslate"><span class="pre">write_block</span></code> 将缓冲区中的内容写回到磁盘块中。</p>
<p>事实上，无论站在代码实现鲁棒性还是性能的角度，将这些缓冲区合理的管理起来都是很有必要的。一种完全不进行任何管理的模式可能是：每当要对一个磁盘块进行读写的时候，都通过 <code class="docutils literal notranslate"><span class="pre">read_block</span></code> 将块数据读取到一个 <em>临时</em> 创建的缓冲区，并在进行一些操作之后（可选地）将缓冲区的内容写回到磁盘块。从性能上考虑，我们需要尽可能降低真正块读写（即 <code class="docutils literal notranslate"><span class="pre">read/write_block</span></code> ）的次数，因为每一次调用它们都会产生大量开销。要做到这一点，关键就在于对于块读写操作进行 <strong>合并</strong> 。例如，如果一个块已经被读到缓冲区中了，那么我们就没有必要再读一遍，直接用已有的缓冲区就行了；同时，对于同一个块的缓冲区的多次修改没有必要每次都写回磁盘，只需等所有的修改都结束之后统一写回磁盘即可。</p>
<p>但是，当磁盘上的数据结构比较复杂的时候，在编程的时候我们很难手动正确的规划块读取/写入的时机。这不仅可能涉及到复杂的参数传递，稍有不慎还有可能引入同步性问题：即对于一个块缓冲区的修改在对于同一个块进行后续操作的时候不可见。它很致命但又难以调试。</p>
<p>因此，我们的做法是将缓冲区统一管理起来。当我们要读写一个块的时候，首先就是去全局管理器中查看这个块是否已被缓存到内存中的缓冲区中。这样，在一段连续时间内对于一个块进行的所有操作均是在同一个固定的缓冲区中进行的，这解决了同步性问题。此外，通过 <code class="docutils literal notranslate"><span class="pre">read/write_block</span></code> 真正进行块读写的时机完全交给全局管理器处理，我们在编程时无需操心。全局管理器仅会在必要的时机分别发起一次真正的块读写，尽可能将更多的块操作合并起来。</p>
<div class="section" id="id4">
<h3>块缓存<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>块缓存 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 的声明如下：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/lib.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BLOCK_SZ</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">512</span><span class="p">;</span><span class="w"></span>

<span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">BlockCache</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cache</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">modified</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>其中：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cache</span></code> 是一个 512 字节的数组，表示位于内存中的缓冲区；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block_id</span></code> 记录了这个块缓存来自于磁盘中的块的编号；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block_device</span></code> 保留一个底层块设备的引用使得可以和它打交道；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">modified</span></code> 记录自从这个块缓存从磁盘载入内存之后，它有没有被修改过。</p></li>
</ul>
<p>当我们创建一个 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 的时候，这将触发一次 <code class="docutils literal notranslate"><span class="pre">read_block</span></code> 将一个块上的数据从磁盘读到缓冲区 <code class="docutils literal notranslate"><span class="pre">cache</span></code> ：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">BlockCache</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="sd">/// Load a new BlockCache from disk.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">block_device</span><span class="p">.</span><span class="n">read_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">cache</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">cache</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">block_id</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">block_device</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">modified</span>: <span class="nc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>一旦缓冲区已经存在于内存中，CPU 就可以直接访问存储在它上面的磁盘数据结构：</p>
<div class="highlight-rust notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span></pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">BlockCache</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">addr_of_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">type_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">core</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">type_size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">addr_of_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;*</span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_mut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">type_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">core</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">type_size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">modified</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">addr_of_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</td></tr></table></div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">addr_of_offset</span></code> 可以得到一个 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 内部的缓冲区一个指定偏移量 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 的字节地址；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_ref</span></code> 是一个泛型方法，它可以获取缓冲区中的位于偏移量 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 的一个类型为 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的磁盘上数据结构的不可变引用。该泛型方法的 Trait Bound 限制类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 必须是一个编译时已知大小的类型，我们通过 <code class="docutils literal notranslate"><span class="pre">core::mem::size_of::&lt;T&gt;()</span></code> 在编译时获取类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的大小并确认该数据结构被整个包含在磁盘块及其缓冲区之内。这里编译器会自动进行生命周期标注，约束返回的引用的生命周期不超过 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 自身，在使用的时候我们会保证这一点。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_mut</span></code> 与 <code class="docutils literal notranslate"><span class="pre">get_ref</span></code> 的不同之处在于它会会获取磁盘上数据结构的可变引用，由此可以对数据结构进行修改。由于这些数据结构目前位于内存中的缓冲区中，我们需要将 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 的 <code class="docutils literal notranslate"><span class="pre">modified</span></code> 标记为 true 表示该缓冲区已经被修改，之后需要将数据写回磁盘块才能真正将修改同步到磁盘。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 的设计也体现了 RAII 思想， 它管理着一个缓冲区的生命周期。当 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 的生命周期结束之后缓冲区也会被从内存中回收，这个时候 <code class="docutils literal notranslate"><span class="pre">modified</span></code> 标记将会决定数据是否需要写回磁盘：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">BlockCache</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">sync</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">modified</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">modified</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">.</span><span class="n">write_block</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BlockCache</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">sync</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 被 <code class="docutils literal notranslate"><span class="pre">drop</span></code> 的时候，它会首先调用 <code class="docutils literal notranslate"><span class="pre">sync</span></code> 方法，如果自身确实被修改过的话才会将缓冲区的内容写回磁盘。事实上， <code class="docutils literal notranslate"><span class="pre">sync</span></code> 并不是只有在 <code class="docutils literal notranslate"><span class="pre">drop</span></code> 的时候才会被调用。在 Linux 中，通常有一个后台进程负责定期将内存中缓冲区的内容写回磁盘。另外有一个 <code class="docutils literal notranslate"><span class="pre">sys_fsync</span></code> 系统调用可以手动通知内核将一个文件的修改同步回磁盘。由于我们的实现比较简单， <code class="docutils literal notranslate"><span class="pre">sync</span></code> 仅会在 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 被 <code class="docutils literal notranslate"><span class="pre">drop</span></code> 时才会被调用。</p>
<p>我们可以将 <code class="docutils literal notranslate"><span class="pre">get_ref/get_mut</span></code> 进一步封装为更为易用的形式：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">BlockCache</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">read</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">V</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">V</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">get_ref</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">modify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span>:<span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">V</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">V</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">get_mut</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>它们的含义是：在 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 缓冲区偏移量为 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 的位置获取一个类型为 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的磁盘上数据结构的不可变/可变引用（分别对应 <code class="docutils literal notranslate"><span class="pre">read/modify</span></code> ），并让它进行传入的闭包 <code class="docutils literal notranslate"><span class="pre">f</span></code> 中所定义的操作。注意 <code class="docutils literal notranslate"><span class="pre">read/modify</span></code> 的返回值是和传入闭包的返回值相同的，因此相当于 <code class="docutils literal notranslate"><span class="pre">read/modify</span></code> 构成了传入闭包 <code class="docutils literal notranslate"><span class="pre">f</span></code> 的一层执行环境，让它能够真正绑定到一个缓冲区开始执行。</p>
<p>这里我们传入闭包的类型为 <code class="docutils literal notranslate"><span class="pre">FnOnce</span></code> ，这是因为闭包里面的变量被捕获的方式涵盖了不可变引用/可变引用/和 move 三种可能性，故而我们需要选取范围最广的 <code class="docutils literal notranslate"><span class="pre">FnOnce</span></code> 。参数中的 <code class="docutils literal notranslate"><span class="pre">impl</span></code> 关键字体现了一种类似泛型的静态分发功能。</p>
<p>我们很快将展示 <code class="docutils literal notranslate"><span class="pre">read/modify</span></code> 接口如何在后续的开发中提供便利。</p>
</div>
<div class="section" id="id5">
<h3>块缓存全局管理器<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>为了避免在块缓存上浪费过多内存，我们希望内存中同时只能驻留有限个磁盘块的缓冲区：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">const</span><span class="w"> </span><span class="n">BLOCK_CACHE_SIZE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>块缓存全局管理器的功能是：当我们要对一个磁盘块进行读写从而需要获取它的缓冲区的时候，首先看它是否已经被载入到内存中了，如果已经被载入的话则直接返回，否则需要读取磁盘块的数据到内存中。此时，如果内存中驻留的磁盘块缓冲区的数量已满，则需要遵循某种缓存替换算法将某个块的缓冲区从内存中移除，再将刚刚请求的块的缓冲区加入到内存中。我们这里使用一种类 FIFO 的简单缓存替换算法，因此在管理器中只需维护一个队列：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">use</span><span class="w"> </span><span class="n">alloc</span>::<span class="n">collections</span>::<span class="n">VecDeque</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">BlockCacheManager</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">queue</span>: <span class="nc">VecDeque</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">BlockCache</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">BlockCacheManager</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">queue</span>: <span class="nc">VecDeque</span>::<span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>队列 <code class="docutils literal notranslate"><span class="pre">queue</span></code> 中管理的是块编号和块缓存的二元组。块编号的类型为 <code class="docutils literal notranslate"><span class="pre">usize</span></code> ，而块缓存的类型则是一个 <code class="docutils literal notranslate"><span class="pre">Arc&lt;Mutex&lt;BlockCache&gt;&gt;</span></code> 。这是一个此前频频提及到的 Rust 中的经典组合，它可以同时提供共享引用和互斥访问。这里的共享引用意义在于块缓存既需要在管理器 <code class="docutils literal notranslate"><span class="pre">BlockCacheManager</span></code> 保留一个引用，还需要以引用的形式返回给块缓存的请求者让它可以对块缓存进行访问。而互斥访问在单核上的意义在于提供内部可变性通过编译，在多核环境下则可以帮助我们避免可能的并发冲突。事实上，一般情况下我们需要在更上层提供保护措施避免两个线程同时对一个块缓存进行读写，因此这里只是比较谨慎的留下一层保险。</p>
<p><code class="docutils literal notranslate"><span class="pre">get_block_cache</span></code> 方法尝试从块缓存管理器中获取一个编号为 <code class="docutils literal notranslate"><span class="pre">block_id</span></code> 的块的块缓存，如果找不到的话会从磁盘读取到内存中，还有可能会发生缓存替换：</p>
<div class="highlight-rust notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span></pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">BlockCacheManager</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_block_cache</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">BlockCache</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">|</span><span class="n">pair</span><span class="o">|</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">block_id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pair</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// substitute</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BLOCK_CACHE_SIZE</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="c1">// from front to tail</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">enumerate</span><span class="p">()</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pair</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">drain</span><span class="p">(</span><span class="n">idx</span><span class="o">..=</span><span class="n">idx</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;Run out of BlockCache!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="c1">// load block into mem and push back</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">block_cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="n">BlockCache</span>::<span class="n">new</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_device</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_cache</span><span class="p">)));</span><span class="w"></span>
<span class="w">            </span><span class="n">block_cache</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</td></tr></table></div>
<ul>
<li><p>第 9 行会遍历整个队列试图找到一个编号相同的块缓存，如果找到了话会将块缓存管理器中保存的块缓存的引用复制一份并返回；</p></li>
<li><p>第 13 行对应找不到的情况，此时必须将块从磁盘读入内存中的缓冲区。在实际读取之前需要判断管理器保存的块缓存数量是否已经达到了上限。如果达到了上限（第 15 行）才需要执行缓存替换算法丢掉某个块的缓存空出一个空位。这里使用一种类 FIFO 算法，如果是 FIFO 算法的话，每次加入一个缓存的时候需要从队尾加入，需要替换的时候则从队头弹出。但是此时队头对应的块缓存可能仍在使用：判断的标志是其强引用计数 <span class="math notranslate nohighlight">\(\geq 2\)</span> ，即除了块缓存管理器保留的一份副本之外，在外面还有若干份副本正在使用。因此，我们的做法是从队头遍历到队尾找到第一个强引用计数恰好为 1 的块缓存并将其替换出去。</p>
<p>那么是否有可能出现队列已满且其中所有的块缓存都正在使用的情形呢？事实上，只要我们的上限 <code class="docutils literal notranslate"><span class="pre">BLOCK_CACHE_SIZE</span></code> 设置的足够大，超过所有线程同时访问的块总数上限，那么这种情况永远不会发生。但是，如果我们的上限设置不足，这里我们就只能 panic 。</p>
</li>
<li><p>第 27 行开始我们创建一个新的块缓存（会触发 <code class="docutils literal notranslate"><span class="pre">read_block</span></code> 进行块读取）并加入到队尾，最后返回给请求者。</p></li>
</ul>
<p>接下来需要创建 <code class="docutils literal notranslate"><span class="pre">BlockCacheManager</span></code> 的全局实例：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="n">lazy_static</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">BLOCK_CACHE_MANAGER</span>: <span class="nc">Mutex</span><span class="o">&lt;</span><span class="n">BlockCacheManager</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">BlockCacheManager</span>::<span class="n">new</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_block_cache</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">BlockCache</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">BLOCK_CACHE_MANAGER</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">get_block_cache</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="n">block_device</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>之后，对于其他模块而言就可以直接通过 <code class="docutils literal notranslate"><span class="pre">get_block_cache</span></code> 方法来请求块缓存了。这里需要指出的是，它返回的是一个 <code class="docutils literal notranslate"><span class="pre">Arc&lt;Mutex&lt;BlockCache&gt;&gt;</span></code> ，调用者需要通过 <code class="docutils literal notranslate"><span class="pre">.lock()</span></code> 获取里层互斥锁 <code class="docutils literal notranslate"><span class="pre">Mutex</span></code> 才能对最里面的 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 进行操作，比如通过 <code class="docutils literal notranslate"><span class="pre">read/modify</span></code> 访问缓冲区里面的磁盘数据结构。</p>
</div>
</div>
<div class="section" id="id6">
<h2>磁盘布局及磁盘上数据结构<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>对于一个文件系统而言，最重要的功能是如何将一个逻辑上的目录树结构映射到磁盘上，决定磁盘上的每个块应该存储哪些数据。为了更容易进行管理和更新，我们需要将磁盘上的数据组织为若干种不同的磁盘上数据结构，并合理安排它们在磁盘中的位置。</p>
<div class="section" id="id7">
<h3>easy-fs 磁盘布局概述<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>在 easy-fs 磁盘布局中，按照块编号从小到大可以分成 5 个连续区域：</p>
<ul class="simple">
<li><p>最开始的区域长度为一个块，其内容是 easy-fs <strong>超级块</strong> (Super Block)，超级块内以魔数的形式提供了文件系统合法性检查功能，同时还可以定位其他连续区域的位置。</p></li>
<li><p>接下来的一个区域是一个索引节点位图，长度为若干个块。它记录了后面的索引节点区域中有哪些索引节点已经被分配出去使用了，而哪些还尚未被分配出去。</p></li>
<li><p>接下来的一个区域是索引节点区域，长度为若干个块。其中的每个块都存储了若干个索引节点。</p></li>
<li><p>接下来的一个区域是一个数据块位图，长度为若干个块。它记录了后面的数据块区域中有哪些数据块已经被分配出去使用了，而哪些还尚未被分配出去。</p></li>
<li><p>最后的一个区域则是数据块区域，顾名思义，其中的每一个块的职能都是作为一个数据块实际保存文件或目录中的数据。</p></li>
</ul>
<p><strong>索引节点</strong> (Inode, Index Node) 是文件系统中的一种重要数据结构。逻辑目录树结构中的每个文件和目录都对应一个 inode ，我们前面提到的在文件系统实现中文件/目录的底层编号实际上就是指 inode 编号。在 inode 中不仅包含了我们通过 <code class="docutils literal notranslate"><span class="pre">stat</span></code> 工具能够看到的文件/目录的元数据（大小/访问权限/类型等信息），还包含它到那些实际保存文件/目录数据的数据块（位于最后的数据块区域中）的索引信息，从而能够找到文件/目录的数据被保存在哪里。从索引方式上看，同时支持直接索引和间接索引。</p>
<p>每个区域中均存储着不同的磁盘数据结构，它们能够对磁盘中的数据进行解释并将其结构化。下面我们分别对它们进行介绍。</p>
</div>
<div class="section" id="id8">
<h3>easy-fs 超级块<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>超级块 <code class="docutils literal notranslate"><span class="pre">SuperBlock</span></code> 的内容如下：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="cp">#[repr(C)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">SuperBlock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">magic</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">total_blocks</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">inode_bitmap_blocks</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">inode_area_blocks</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">data_bitmap_blocks</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">data_area_blocks</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>其中， <code class="docutils literal notranslate"><span class="pre">magic</span></code> 是一个用于文件系统合法性验证的魔数， <code class="docutils literal notranslate"><span class="pre">total_block</span></code> 给出文件系统的总块数。注意这并不等同于所在磁盘的总块数，因为文件系统很可能并没有占据整个磁盘。后面的四个字段则分别给出 easy-fs 布局中后四个连续区域的长度各为多少个块。</p>
<p>下面是它实现的方法：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">SuperBlock</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">initialize</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">total_blocks</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">inode_bitmap_blocks</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">inode_area_blocks</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">data_bitmap_blocks</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">data_area_blocks</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">magic</span>: <span class="nc">EFS_MAGIC</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">total_blocks</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">inode_bitmap_blocks</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">inode_area_blocks</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">data_bitmap_blocks</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">data_area_blocks</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">is_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">magic</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EFS_MAGIC</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initialize</span></code> 可以在创建一个 easy-fs 的时候对超级块进行初始化，注意各个区域的块数是以参数的形式传入进来的，它们的划分是更上层的磁盘块管理器需要完成的工作。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_valid</span></code> 则可以通过魔数判断超级块所在的文件系统是否合法。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">SuperBlock</span></code> 是一个磁盘上数据结构，它就存放在磁盘上编号为 0 的块的开头。</p>
</div>
<div class="section" id="id9">
<h3>位图<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>在 easy-fs 布局中存在两个不同的位图，分别对于索引节点和数据块进行管理。每个位图都由若干个块组成，每个块大小为 512 字节，即 4096 个比特。每个比特都代表一个索引节点/数据块的分配状态， 0 意味着未分配，而 1 则意味着已经分配出去。位图所要做的事情是通过比特位的分配（寻找一个为 0 的比特位设置为 1）和回收（将比特位清零）来进行索引节点/数据块的分配和回收。</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/bitmap.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Bitmap</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">start_block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">blocks</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Bitmap</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">start_block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">blocks</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">start_block_id</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">blocks</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>位图 <code class="docutils literal notranslate"><span class="pre">Bitmap</span></code> 中仅保存了它所在区域的起始块编号以及区域的长度为多少个块。通过 <code class="docutils literal notranslate"><span class="pre">new</span></code> 方法可以新建一个位图。注意 <code class="docutils literal notranslate"><span class="pre">Bitmap</span></code> 自身是驻留在内存中的，但是它能够控制它所在区域的那些磁盘块。磁盘块上的数据则是要以磁盘数据结构 <code class="docutils literal notranslate"><span class="pre">BitmapBlock</span></code> 的格式进行操作：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/bitmap.rs</span>

<span class="k">type</span> <span class="nc">BitmapBlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="mi">64</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BitmapBlock</span></code> 是一个磁盘数据结构，它将位图区域中的一个磁盘块解释为长度为 64 的一个 <code class="docutils literal notranslate"><span class="pre">u64</span></code> 数组， 每个 <code class="docutils literal notranslate"><span class="pre">u64</span></code> 打包了一组 64 个比特，于是整个数组包含 <span class="math notranslate nohighlight">\(64\times 64=4096\)</span> 个比特，且可以以组为单位进行操作。</p>
<p>首先来看 <code class="docutils literal notranslate"><span class="pre">Bitmap</span></code> 如何分配一个比特：</p>
<div class="highlight-rust notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span></pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/bitmap.rs</span>

<span class="k">const</span><span class="w"> </span><span class="n">BLOCK_BITS</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Bitmap</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">block_device</span>: <span class="kp">&amp;</span><span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">block_id</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="bp">self</span><span class="p">.</span><span class="n">blocks</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_block_cache</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="n">block_id</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">start_block_id</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="n">block_device</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">lock</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">modify</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">bitmap_block</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">BitmapBlock</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">bits64_pos</span><span class="p">,</span><span class="w"> </span><span class="n">inner_pos</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bitmap_block</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">enumerate</span><span class="p">()</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">bits64</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="o">**</span><span class="n">bits64</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">u64</span>::<span class="n">MAX</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">bits64_pos</span><span class="p">,</span><span class="w"> </span><span class="n">bits64</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="p">(</span><span class="n">bits64_pos</span><span class="p">,</span><span class="w"> </span><span class="n">bits64</span><span class="p">.</span><span class="n">trailing_ones</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="p">})</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="c1">// modify cache</span>
<span class="w">                    </span><span class="n">bitmap_block</span><span class="p">[</span><span class="n">bits64_pos</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mi">1</span><span class="k">u64</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">inner_pos</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="nb">Some</span><span class="p">(</span><span class="n">block_id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BLOCK_BITS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bits64_pos</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inner_pos</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="nb">None</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">});</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">pos</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="nb">None</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</td></tr></table></div>
<p>其主要思路是遍历区域中的每个块，再在每个块中以比特组（每组 64 比特）为单位进行遍历，找到一个尚未被全部分配出去的组，最后在里面分配一个比特。它将会返回分配的比特所在的位置，等同于索引节点/数据块的编号。如果所有比特均已经被分配出去了，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
</div>
<div class="section" id="id10">
<h3>磁盘上索引节点<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
</div>
<div class="section" id="id11">
<h3>数据块与目录项<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
</div>
</div>
<div class="section" id="id12">
<h2>磁盘块管理器<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
</div>
<div class="section" id="id13">
<h2>索引节点<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
</div>
<div class="section" id="id14">
<h2>测试 easy-fs<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
</div>
<div class="section" id="id15">
<h2>将应用打包为 easy-fs 镜像<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="3using-easy-fs-in-kernel.html" class="btn btn-neutral float-right" title="在内核中使用 easy-fs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="1fs-interface.html" class="btn btn-neutral float-left" title="文件系统接口" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2020, Yifan Wu.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>