练习
===========================================

课后练习
-------------------------------

编程题
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在Linux环境中，基于pthread线程，有一系列的系统调用实现对应用程序的线程间同步互斥的支持。

信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：P(SV): 如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。V(SV)： 如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。其系统调用为：

- sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。
- sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。
  
互斥量：互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区 时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：

- pthread_mutex_init: 初始化互斥锁
- pthread_mutex_destroy： 销毁互斥锁
- pthread_mutex_lock： 以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。
- pthread_mutex_unlock: 以一个原子操作的方式给一个互斥锁解锁。


条件变量:条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：

- pthread_cond_init: 初始化条件变量
- pthread_cond_destroy： 销毁条件变量
- pthread_cond_signal： 唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。
- pthread_cond_wait： 等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。

1. `**` 在Linux环境下，请用信号量实现哲学家就餐的多线程应用程序。
2. `**` 在Linux环境下，请用互斥锁和条件变量实现哲学家就餐的多线程应用程序。
3. `**` 在Linux环境下，请建立一个多线程的模拟资源分配管理库，可通过银行家算法来避免死锁。
4. `**`  扩展内核功能，实现读者优先的读写信号量。
5. `**`  扩展内核功能，实现写者优先的读写信号量。
6. `***` 扩展内核功能，在内核中支持内核线程。
7. `***` 进一步扩展内核功能，在内核线程中支持同步互斥机制，实现内核线程用的mutex, semaphore, cond-var。
8. `***` 扩展内核功能，实现多核支持下的同步互斥机制。
9. `***` 解决优先级反转问题：实现RM实时调度算法，设计优先级反转的实例，实现优先级天花板和优先级继承方法。

问答题
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. `*` 什么是并行？什么是并发？
2. `*` 为了创造临界区，单核处理器上可以【关中断】，多核处理器上需要使用【自旋锁】。请回答下列问题：

    - 多核上可不可以只用【关中断】？ 
    - 单核上可不可以只用【自旋锁】？
    - 多核上的【自旋锁】是否需要同时【关中断】？
    - [进阶] 假如某个锁不会在中断处理函数中被访问，是否还需要【关中断】？

3. `**` Linux的多线程应用程序使用的锁（例如 pthread_mutex_t）不是自旋锁，当上锁失败时会切换到其它进程执行。分析它和自旋锁的优劣，并说明为什么它不用自旋锁？
4. `***` 程序在运行时具有两种性质：safety: something bad will never happen；liveness: something good will eventually occur. 分析并证明 Peterson 算法的 safety 和 liveness 性质。
5. `*` 信号量结构中的整数分别为+n、0、-n 的时候，各自代表什么状态或含义？
6.  `**` 考虑如下信号量实现代码：

.. code-block:: rust

    class Semaphore {
      int sem;
      WaitQueue q;
    }
    Semaphore::P() {
      sem --;
      if(sem < 0) {
        Add this thread to q.
        block.
      }
    }
    Semaphore::V() {
      sem ++;
      if(sem <= 0) {
        t = Remove a thread from q;
        wakeup(t);
      }
    }

假如 P操作或V操作不是原子操作，会出现什么问题？举一个例子说明。上述代码能否运行在用户态？上面代码的原子性是如何保证的？

7.  `**` 条件变量的 Wait 操作为什么必须关联一个锁？

8. `**` 下面是条件变量的wait操作实现伪代码：

.. code-block:: rust

    Condvar::wait(lock) {
      Add this thread to q.
      lock.unlock();
      schedule();
      lock.lock();
    }

如果改成下面这样：

.. code-block:: rust

    Condvar::wait() {
      Add this thread to q.
      schedule();
    }
    lock.unlock();
    condvar.wait();
    lock.lock();

会出现什么问题？举一个例子说明。

9. `*` 死锁的必要条件是什么？
10. `*` 什么是死锁预防，举例并分析。
11. `**` 描述银行家算法如何判断安全性。

实验练习
-------------------------------

实验练习包括实践作业和问答作业两部分。


编程作业
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

并发
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

这一章我们实现了并发机制...
  
实验要求
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


问答作业
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


实验练习的提交报告要求
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* 简单总结本次实验与上个实验相比你增加的东西。（控制在5行以内，不要贴代码）
* 完成问答问题
* (optional) 你对本次实验设计及难度的看法。